<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="md_doc_markdown_interactions" kind="page">
    <compoundname>md_doc_markdown_interactions</compoundname>
    <title>Interactions</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<sect1 id="md_doc_markdown_interactions_1md-interactions">
<title>Interactions in libmd</title>
<para>Interactions are of two types: pair potentials and forcetypes. In molecular dynamics, the <emphasis>forces</emphasis> on each particle are computed at each time step as a function of neighbouring particles, external constraints, etc. Pair porentials are a concise way of defining central forces that can be written as a gradient of a potential energy, whereas forcetypes encompass all other possibilities.</para>
<sect2 id="md_doc_markdown_interactions_1md-pairpotentials">
<title>Conservative forces</title>
<para>Molecular dynamics simulations often include conservative forces between pairs of particles, which depend only on the distance between the two particles and act along the vector joining them. They can be written as the gradient of a potential energy <formula id="4">$V(r)$</formula> that depends on the separation distance. If <formula id="5">$\mathbf{r}_i$</formula> and <formula id="6">$\mathbf{r}_j$</formula> are the position vectors of two particles, then the pairwise central forces on each particle are <formula id="7">\[ \mathbf{F}_i = -\nabla_{\mathbf{r}_i} V(|\mathbf{r}_i-\mathbf{r}_j|) = -\mathbf{F}_j \]</formula></para>
<para><computeroutput>libmd</computeroutput> uses the framework of <emphasis>particle types</emphasis> to define pairwise interactions. Every <ref refid="structparticle" kindref="compound">particle</ref> instance has an associated <computeroutput>type</computeroutput>, an <computeroutput>unsigned int</computeroutput> stored in the <computeroutput><ref refid="structparticle_a252424154ec51cc2f0e9c77bb6207c9a_1a252424154ec51cc2f0e9c77bb6207c9a" kindref="member">particle.type</ref></computeroutput> variable. Interactions are defined between pairs of particle types. For instance, a system of identical particles interacting via a Yukawa potential can be set up by assigning the same particle type, say <computeroutput>0</computeroutput>, to all particles in the system, and defining a Yukawa-type interaction between the pair of particle types <computeroutput>(0,0)</computeroutput>.</para>
<para>The particle type is set while creating a <ref refid="structparticle" kindref="compound">particle</ref> instance via the <computeroutput>ptype</computeroutput> argument of the <ref refid="structparticle_ad330f8e1c58bc0e3aacb296da3122925_1ad330f8e1c58bc0e3aacb296da3122925" kindref="member">particle&lt;dim&gt;::particle</ref> constructor, and can be updated by calling the <ref refid="structmd_a9282fd8d82a54bb7d4f76685c3bf5432_1a9282fd8d82a54bb7d4f76685c3bf5432" kindref="member">md&lt;dim&gt;::set_type(ui p, ui newtype)</ref> function.</para>
<para>Defining a pairwise interaction between two particle types requires making a distinction between <emphasis>pair potentials</emphasis> and <emphasis>interactions</emphasis>:</para>
<para><itemizedlist>
<listitem><para>A <emphasis>pair potential</emphasis> is the definition of a potential function <formula id="4">$V(r)$</formula> that may depend on some parameters in addition to the particle separation <formula id="8">$r$</formula>. The <ref refid="structmd_a9a603fe30e2611cef18b6d597335610e_1a9a603fe30e2611cef18b6d597335610e" kindref="member">md&lt;dim&gt;::v</ref> structure stores information about pair potentials in the simulation. See the subsection on <ulink url="#md-pairpotentialdef">pair potentials</ulink> for more information.</para>
</listitem><listitem><para>An <emphasis>interaction</emphasis> is a combination of a pair potential and a specific set of parameters. The <ref refid="structmd_af03ae636b8618d85a9f7088077fef25d_1af03ae636b8618d85a9f7088077fef25d" kindref="member">md&lt;dim&gt;::network</ref> structure stores information about the interactions deriving from pair potentials in the system. See the subsection on <ulink url="#md-interactiondef">interactions</ulink> for more information.</para>
</listitem></itemizedlist>
</para>
<sect3 id="md_doc_markdown_interactions_1md-pairpotentialdef">
<title>Pair potentials</title>
<para>Pair potential functions are defined outside the <computeroutput>md&lt;dim&gt;()</computeroutput> structure, and added to the simulation using function pointers. A pair potential function takes two arguments: the separation distance <computeroutput>r</computeroutput> and a pointer <computeroutput>vector&lt;ldf&gt; &amp;params</computeroutput> to a vector of <computeroutput>float</computeroutput>s that contains the parameters needed to compute the interaction, and returns the potential energy. <computeroutput>libmd</computeroutput> uses <ulink url="http://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</ulink> implemented in <ref refid="autodiff_8libmd_8cc" kindref="compound">autodiff.libmd.cc</ref> to calculate the forces from the potential definition. This mandates that the potential function be defined with the first argument (the distance <computeroutput>r</computeroutput>) and the return value having a templated type: <programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>X&gt;<sp/>X<sp/>my_potential(X<sp/>r,vector&lt;ldf&gt;<sp/>&amp;parameters)<sp/>{...}</highlight></codeline>
</programlisting> However, the function itself can be written by treating <computeroutput>r</computeroutput> and the return value as <computeroutput>ldf</computeroutput> variables. See <ref refid="potentials_8libmd_8cc" kindref="compound">potentials.libmd.cc</ref> for example definitions of potential functions.</para>
<para>Once the potential function has been defined, a function pointer pointing to it is added to the list of potential functions <computeroutput>md&lt;dim&gt;::v.potentials</computeroutput> through a call to the <ref refid="structpairpotentials_a41a8b85ded4ddaf1896a5d3de69402b8_1a41a8b85ded4ddaf1896a5d3de69402b8" kindref="member">pairpotentials::add()</ref> member function of <ref refid="structmd_a9a603fe30e2611cef18b6d597335610e_1a9a603fe30e2611cef18b6d597335610e" kindref="member">md&lt;dim&gt;::v</ref>. Each added potential is given a unique index, which is the return value of <computeroutput>md&lt;dim&gt;::v.add()</computeroutput>. The following command adds the potential function <computeroutput>my_potential()</computeroutput> defined above to an <computeroutput>md&lt;dim&gt;</computeroutput> instance named <computeroutput>sys</computeroutput>, and stores the associated index in <computeroutput>pidx:</computeroutput> <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="structmd" kindref="compound">md&lt;dim&gt;</ref><sp/>sys;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">ui<sp/>pidx<sp/>=<sp/>sys.<ref refid="structmd_a9a603fe30e2611cef18b6d597335610e_1a9a603fe30e2611cef18b6d597335610e" kindref="member">v</ref>.<ref refid="structpairpotentials_a41a8b85ded4ddaf1896a5d3de69402b8_1a41a8b85ded4ddaf1896a5d3de69402b8" kindref="member">add</ref>(my_potential&lt;dual&gt;);</highlight></codeline>
</programlisting> (The <computeroutput>&lt;dual&gt;</computeroutput> template argument is needed for the automatic differentiation system.) This index is then used to define interactions between pairs of particle types through calls to <ref refid="structmd_add32e6f0299fad6d17eea4e0c5172c5f_1add32e6f0299fad6d17eea4e0c5172c5f" kindref="member">md&lt;dim&gt;::add_interaction</ref> and <ref refid="structmd_adc523a066b2afdebc5cfd3f36fa732e6_1adc523a066b2afdebc5cfd3f36fa732e6" kindref="member">md&lt;dim&gt;::add_typeinteraction</ref> functions catalogued in the subsection on <ulink url="#md-interactiondef">interactions</ulink>.</para>
<sect4 id="md_doc_markdown_interactions_1autotoc_md0">
<title>Predefined pair potentials</title>
<para><computeroutput>libmd</computeroutput> comes with some predefined pair potentials that can be combined with any choices of parameters to easily define interactions between particle types. A complete listing is available in the documentation for the <ref refid="potentials_8libmd_8cc" kindref="compound">potentials.libmd.cc</ref> file. The potentials are pre-loaded into the <computeroutput>md&lt;dim&gt;::v.potentials</computeroutput> list of every <ref refid="structmd" kindref="compound">md</ref> instance, and are to be referenced by their positions in this list. For ease of indexing, a global enum structure <ref refid="struct_p_o_t" kindref="compound">POT</ref> has been defined, with <computeroutput><ref refid="struct_p_o_t" kindref="compound">POT</ref>::&lt;potential name&gt;</computeroutput> providing the appropriate pair potential index. For instance, <ref refid="struct_p_o_t_a5b5bcf993bbc4ea93398fabf9f8b78f0_1a5b5bcf993bbc4ea93398fabf9f8b78f0a8728188b5c3f783e3f9a80f000877a56" kindref="member">POT::COULOMB</ref> is the index of the predefined <ref refid="potentials_8libmd_8cc_ad848edbfe46941489261f84096adb972_1ad848edbfe46941489261f84096adb972" kindref="member">COULOMB()</ref> potential.</para>
</sect4>
</sect3>
<sect3 id="md_doc_markdown_interactions_1md-interactiondef">
<title>Interactions</title>
<para>Once a potential has been added to the <ref refid="structmd" kindref="compound">md</ref> instance, it can be combined with specific values of parameters to create distinct <emphasis>interactions</emphasis>, which are instances of the <ref refid="structinteractiontype" kindref="compound">interactiontype</ref> structure. Each <ref refid="structmd" kindref="compound">md</ref> instance has a library of interactions, stored in <computeroutput>md&lt;dim&gt;::network.library[]</computeroutput> which is a vector of <ref refid="structinteractiontype" kindref="compound">interactiontype</ref> instances. Different interactions are indexed by their position in this vector.</para>
<para>Entries in the interaction library are added, modified and removed using the following set of functions:</para>
<para><itemizedlist>
<listitem><para>md&lt;dim&gt;::add_interaction(ui pidx, vector&lt;ldf&gt; &amp;parameters) creates an interaction from the pair potential indexed by <computeroutput>pidx</computeroutput> with the given parameters. The return value is the index of the interaction in <computeroutput>md&lt;dim&gt;::network.library[]</computeroutput>, which we will call <computeroutput>iidx</computeroutput>.</para>
</listitem><listitem><para>md&lt;dim&gt;::mod_interaction(ui iidx, ui pidx,vector&lt;ldf&gt; &amp;parameters) replaces the potential function and parameters of the interaction indexed by <computeroutput>iidx</computeroutput>.</para>
</listitem><listitem><para><ref refid="structmd_a9912870aa754f0366ea2f3b54cf5bfaa_1a9912870aa754f0366ea2f3b54cf5bfaa" kindref="member">md&lt;dim&gt;::rem_interaction(ui iidx)</ref> removes the interaction indexed by <computeroutput>iidx</computeroutput>.</para>
</listitem></itemizedlist>
</para>
<para>The following set of functions assigns a particular interaction indexed by <computeroutput>iidx</computeroutput> to act between particles of types <computeroutput>type1</computeroutput> and <computeroutput>type2:</computeroutput> </para>
<para><itemizedlist>
<listitem><para><ref refid="structmd_adc523a066b2afdebc5cfd3f36fa732e6_1adc523a066b2afdebc5cfd3f36fa732e6" kindref="member">md&lt;dim&gt;::add_typeinteraction(ui type1, ui type2, ui iidx)</ref></para>
</listitem><listitem><para><ref refid="structmd_a3a632d96257e09cdd541aefb1b1f2910_1a3a632d96257e09cdd541aefb1b1f2910" kindref="member">md&lt;dim&gt;::mod_typeinteraction(ui type1, ui type2, ui iidx)</ref></para>
</listitem><listitem><para><ref refid="structmd_ade6485112233e29238898268e6d5813c_1ade6485112233e29238898268e6d5813c" kindref="member">md&lt;dim&gt;::mad_typeinteraction(ui type1, ui type2, ui iidx)</ref></para>
</listitem></itemizedlist>
</para>
<para>The functions differ in their behaviour when an interaction between the pair of types has or has not been defined.</para>
<para>There is also a set of functions which allows the creation of an interaction and its assignment to act between particle types <computeroutput>type1</computeroutput> and <computeroutput>type2</computeroutput> in a single command:</para>
<para><itemizedlist>
<listitem><para>md&lt;dim&gt;::add_typeinteraction(ui type1, ui type2, ui pidx, vector&lt;ldf&gt; &amp;parameters)</para>
</listitem><listitem><para>md&lt;dim&gt;::mod_typeinteraction(ui type1, ui type2, ui pidx, vector&lt;ldf&gt; &amp;parameters)</para>
</listitem><listitem><para>md&lt;dim&gt;::mad_typeinteraction(ui type1, ui type2, ui pidx, vector&lt;ldf&gt; &amp;parameters)</para>
</listitem></itemizedlist>
</para>
<para>The following code snippets are therefore equivalent: <programlisting filename=".cpp"><codeline><highlight class="comment">/*<sp/>Uses<sp/>predefined<sp/>Hookean<sp/>spring<sp/>potential,<sp/>indexed<sp/>by<sp/>POT::HOOKEAN<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">vector&lt;ldf&gt;<sp/>params<sp/>=<sp/>{1.0,2.0};<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Vector<sp/>of<sp/>two<sp/>parameters<sp/>for<sp/>a<sp/>Hookean<sp/>spring</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>(spring<sp/>constant<sp/>and<sp/>rest<sp/>length)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="libmd_8h_aa0f39ee33b87675e11229913d432ffe7_1aa0f39ee33b87675e11229913d432ffe7" kindref="member">ui</ref><sp/>onespring<sp/>=<sp/><ref refid="structmd_add32e6f0299fad6d17eea4e0c5172c5f_1add32e6f0299fad6d17eea4e0c5172c5f" kindref="member">md&lt;dim&gt;::add_interaction</ref>(<ref refid="struct_p_o_t_a5b5bcf993bbc4ea93398fabf9f8b78f0_1a5b5bcf993bbc4ea93398fabf9f8b78f0a1aef82e1cdd2746810e5360f230e9994" kindref="member">POT::HOOKEAN</ref>,<sp/>&amp;params);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>Hookean<sp/>interaction<sp/>with<sp/>the<sp/>given<sp/>parameters</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>and<sp/>store<sp/>its<sp/>index<sp/>in<sp/>onespring</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="structmd_adc523a066b2afdebc5cfd3f36fa732e6_1adc523a066b2afdebc5cfd3f36fa732e6" kindref="member">md&lt;dim&gt;::add_typeinteraction</ref>(2,8,onespring);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>the<sp/>interaction<sp/>indexed<sp/>by<sp/>onespring<sp/>between</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>particle<sp/>types<sp/>2<sp/>and<sp/>8</highlight></codeline>
</programlisting></para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">/*<sp/>Uses<sp/>predefined<sp/>Hookean<sp/>spring<sp/>potential,<sp/>indexed<sp/>by<sp/>POT::HOOKEAN<sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">vector&lt;ldf&gt;<sp/>params<sp/>=<sp/>{1.0,2.0};<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Vector<sp/>of<sp/>two<sp/>parameters<sp/>for<sp/>a<sp/>Hookean<sp/>spring</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>(spring<sp/>constant<sp/>and<sp/>rest<sp/>length)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="structmd_adc523a066b2afdebc5cfd3f36fa732e6_1adc523a066b2afdebc5cfd3f36fa732e6" kindref="member">md&lt;dim&gt;::add_typeinteraction</ref>(2,8,<ref refid="struct_p_o_t_a5b5bcf993bbc4ea93398fabf9f8b78f0_1a5b5bcf993bbc4ea93398fabf9f8b78f0a1aef82e1cdd2746810e5360f230e9994" kindref="member">POT::HOOKEAN</ref>,&amp;params);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>a<sp/>Hookean<sp/>interaction<sp/>between<sp/>particles<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>type<sp/>2<sp/>and<sp/>type<sp/>8<sp/>with<sp/>defined<sp/>params</highlight></codeline>
</programlisting></para>
<sect4 id="md_doc_markdown_interactions_1autotoc_md1">
<title>Cutoff radius</title>
<para>An important parameter in limiting unnecessary computations of pair potentials is the <emphasis>cutoff radius</emphasis>, a value of the particle separation beyond which the pair potential and resultant force are assumed to be zero. Each interaction (i.e. each <ref refid="structinteractiontype" kindref="compound">interactiontype</ref> instance in <computeroutput>md&lt;dim&gt;::network.library</computeroutput>[]) has a unique cutoff radius stored in the <computeroutput>rco</computeroutput> member variable. By default, this is set to be equal to the value of <computeroutput>md&lt;dim&gt;::network.rco</computeroutput>, which is the case for the examples listed above. However, every function that creates a new interaction also has a version in which the cutoff radius can be explicitly specified as an additional parameter, as follows:</para>
<para><itemizedlist>
<listitem><para>md&lt;dim&gt;::add_interaction(ui pidx, ldf rco, vector&lt;ldf&gt; &amp;parameters)</para>
</listitem><listitem><para>md&lt;dim&gt;::mod_interaction(ui iidx, ui pidx, ldf rco, vector&lt;ldf&gt; &amp;parameters)</para>
</listitem><listitem><para>md&lt;dim&gt;::add_typeinteraction(ui type1, ui type2, ui pidx, ldf rco, vector&lt;ldf&gt; &amp;parameters)</para>
</listitem><listitem><para>md&lt;dim&gt;::mod_typeinteraction(ui type1, ui type2, ui pidx, ldf rco, vector&lt;ldf&gt; &amp;parameters)</para>
</listitem><listitem><para>md&lt;dim&gt;::mad_typeinteraction(ui type1, ui type2, ui pidx, ldf rco, vector&lt;ldf&gt; &amp;parameters)</para>
</listitem></itemizedlist>
</para>
</sect4>
</sect3>
<sect3 id="md_doc_markdown_interactions_1autotoc_md2">
<title>Bonds</title>
<para>A bond is a pair interaction specific to two particles. If two particles share a bond, each has a unique particle type that is not shared with any other particle in the system. As a result, the particles could have a unique interaction that is not shared by any other pair of particles in the system. (This is however not a requirement <ndash/> a bond could be created between particles with an interaction type that is also present between other particle types.)</para>
<para>Bonds provide a framework to assign specific interactions to pairs of particles based on the particle ID rather than the particle type. For instance, a disordered spring network with every spring having a unique bond length or spring constant can be implemented by adding bonds among connected particles, each of which is a Hookean interaction with the appropriate parameters. Many functions exist to automate the task of adding, removing, or modifying bonds between pairs of particles without the user having to keep track of particle type assignments. These are summarized here. All such functions take two particle indices as their first two arguments. The order of the particle indices is unimportant.</para>
<para>Functions to create/modify bonds fall into two classes. The first class assigns a predefined interaction type, referenced by its index <computeroutput>iidx</computeroutput> in <computeroutput>md&lt;dim&gt;::network.library[]</computeroutput>, to the particle pair:</para>
<para><itemizedlist>
<listitem><para><ref refid="structmd_a21674b3d7fe619e81706e844e47bd564_1a21674b3d7fe619e81706e844e47bd564" kindref="member">md&lt;dim&gt;::add_bond(ui p1, ui p2, ui iidx)</ref></para>
</listitem><listitem><para><ref refid="structmd_a0920ab1964184b3c6e533c84f3760013_1a0920ab1964184b3c6e533c84f3760013" kindref="member">md&lt;dim&gt;::mod_bond(ui p1, ui p2, ui iidx)</ref></para>
</listitem><listitem><para><ref refid="structmd_a514405c00064a980786fbea0d037b091_1a514405c00064a980786fbea0d037b091" kindref="member">md&lt;dim&gt;::mad_bond(ui p1, ui p2, ui iidx)</ref></para>
</listitem></itemizedlist>
</para>
<para>The second class creates a new interaction from a specified potential type (referenced by its index <computeroutput>pidx</computeroutput> in <computeroutput>md&lt;dim&gt;::v.potentials[]</computeroutput>) and a parameter list, and assigns this newly created interaction type to the pair of particles:</para>
<para><itemizedlist>
<listitem><para>md&lt;dim&gt;::add_bond(ui p1, ui p2, ui pidx, vector&lt;ldf&gt; &amp;parameters)</para>
</listitem><listitem><para>md&lt;dim&gt;::mod_bond(ui p1, ui p2, ui pidx, vector&lt;ldf&gt; &amp;parameters)</para>
</listitem><listitem><para>md&lt;dim&gt;::mad_bond(ui p1, ui p2, ui pidx, vector&lt;ldf&gt; &amp;parameters)</para>
</listitem></itemizedlist>
</para>
<para>The function <ref refid="structmd_aa0c8d2a3bb58c4da796d2d579a4218f4_1aa0c8d2a3bb58c4da796d2d579a4218f4" kindref="member">md&lt;dim&gt;::rem_bond</ref> removes any interaction (including a pair interaction of non-bond type) between a specified pair of particles. A special convenience function <ref refid="structmd_ad4fa01a066c32eb0338a46e9f728875f_1ad4fa01a066c32eb0338a46e9f728875f" kindref="member">md&lt;dim&gt;::add_spring</ref> enables easy creation of harmonic springs of specified spring constant and rest length between specific particle pairs.</para>
<para><bold>Note:</bold> calling functions to add, remove, or modify bonds between particle pairs typically <bold>changes the particle types</bold> associated with each member of the pair. Therefore, it is best to use bond functions after all particle type and potential assignments have been completed (the bond functions will preserve type interactions through the particle reassignment).</para>
</sect3>
<sect3 id="md_doc_markdown_interactions_1autotoc_md3">
<title>Interactions and bonds within superparticles</title>
<para>Interactions and bonds have a special meaning in the context of <ulink url="#md-superparticles">superparticles</ulink>.</para>
<para>A pairwise <emphasis>interaction</emphasis> can be defined between two particle subtypes <computeroutput>p1</computeroutput> and <computeroutput>p2</computeroutput> within a superparticle type <computeroutput>spt</computeroutput>; this interaction will then be present in all copies of <computeroutput>spt</computeroutput> in the system. The pair potentials and interactions are shared with the ordinary particles (i.e. the same libraries and indices are used), but the <computeroutput>add/mod/mad_typeinteraction</computeroutput>() functions described in the section on <ulink url="#md-interactiondef">interactions</ulink> are replaced by the following functions:</para>
<para><itemizedlist>
<listitem><para><ref refid="structmd_a5b6b06f8347c82462c21b8eb0a6d215b_1a5b6b06f8347c82462c21b8eb0a6d215b" kindref="member">md&lt;dim&gt;::add_sp_interaction(ui spt, ui p1, ui p2, ui iidx)</ref></para>
</listitem><listitem><para>md&lt;dim&gt;::add_sp_interaction(ui spt, ui p1, ui p2, ui pidx, vector&lt;ldf&gt; &amp;parameters)</para>
</listitem><listitem><para>md&lt;dim&gt;::add_sp_interaction(ui spt, ui p1, ui p2, ui pidx, ldf rco, vector&lt;ldf&gt; &amp;parameters)</para>
</listitem></itemizedlist>
</para>
<para>(and similarly for <computeroutput>mod_sp_interaction</computeroutput> and <computeroutput>mad_sp_interaction</computeroutput>).</para>
<para>A <emphasis>bond</emphasis> within a superparticle is created by specifying two <emphasis>ordinary</emphasis> particle indices (not subtypes) <computeroutput>p1</computeroutput> and <computeroutput>p2</computeroutput> which must belong to the same superparticle. An interaction is then created between these two particles, which only exists in that particular superparticle instance, making it distinct from all other superparticles in the system. Successful superparticle bond creation always gives rise to a new superparticle type specific to the superparticle instance that has been targeted. See the following functions for more details:</para>
<para><itemizedlist>
<listitem><para><ref refid="structmd_a5f432ad2fb07d7e3d802d51ef5bec4b3_1a5f432ad2fb07d7e3d802d51ef5bec4b3" kindref="member">md&lt;dim&gt;::add_sp_bond(ui p1, ui p2, ui iidx)</ref></para>
</listitem><listitem><para>md&lt;dim&gt;::add_sp_bond(ui p1, ui p2, ui pidx, vector&lt;ldf&gt; &amp;parameters)</para>
</listitem></itemizedlist>
</para>
<para>(and similarly for <computeroutput>mod_sp_bond</computeroutput> and <computeroutput>mad_sp_bond</computeroutput>).</para>
<para>Finally the functions <ref refid="structmd_a122d80c92758c75eb00437bbc9192e70_1a122d80c92758c75eb00437bbc9192e70" kindref="member">md&lt;dim&gt;::rem_sp_interaction()</ref> and <ref refid="structmd_a06df83013c9455b525f95deb35dd5b55_1a06df83013c9455b525f95deb35dd5b55" kindref="member">md&lt;dim&gt;::rem_sp_bond()</ref> remove superparticle interactions and bonds respectively.</para>
</sect3>
</sect2>
<sect2 id="md_doc_markdown_interactions_1autotoc_md4">
<title>Non-conservative forces</title>
<para>Many applications of molecular dynamics involve forces that cannot be defined as gradients of <ulink url="#md-pairpotentialdef">pair potentials</ulink>; e.g. dissipative drag on a particle. We use the <ref refid="structforcetype" kindref="compound">forcetype</ref> framework to define such forces on particles. This framework is completely general, and can be used to define any number of operations (not restricted to force calculation) on individual particles that can be calculated as a function of particle positions, velocities, or external parameters.</para>
<para>As with conservative forces, a distinction is to be made between <emphasis>external force functions</emphasis> and <emphasis>forcetypes</emphasis>, which are the equivalent of <emphasis>pair potentials</emphasis> and <emphasis>type interactions</emphasis> respectively. Information about external force functions is stored in the <ref refid="structmd_a2997460875452413182c56784f50edaf_1a2997460875452413182c56784f50edaf" kindref="member">md&lt;dim&gt;::f</ref> structure, whereas the forcetypes deriving from these force functions are stored in the <ref refid="structmd_af03ae636b8618d85a9f7088077fef25d_1af03ae636b8618d85a9f7088077fef25d" kindref="member">md&lt;dim&gt;::network</ref> structure (specifically <computeroutput>md&lt;dim&gt;::network.forces</computeroutput> and <computeroutput>md&lt;dim&gt;::network.forcelibrary</computeroutput>).</para>
<sect3 id="md_doc_markdown_interactions_1autotoc_md5">
<title>External force functions</title>
<para>The <ref refid="structforcetype" kindref="compound">forcetype</ref> framework requires operations on particles to be represented as <emphasis>external force functions</emphasis>, which live outside the <computeroutput>md&lt;dim&gt;()</computeroutput> structure and fits the following prototype: <programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;ui<sp/>dim&gt;<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>my_external_force(<ref refid="libmd_8h_aa0f39ee33b87675e11229913d432ffe7_1aa0f39ee33b87675e11229913d432ffe7" kindref="member">ui</ref><sp/>i,<sp/>vector&lt;ui&gt;<sp/>&amp;partners,<sp/>vector&lt;ldf&gt;<sp/>&amp;parameters,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*sys)<sp/>{...}</highlight></codeline>
</programlisting> where <computeroutput>i</computeroutput> is a particle index, <computeroutput>partners</computeroutput> points to a vector of particle indices which might influence particle <computeroutput>i</computeroutput>, and <computeroutput>parameters</computeroutput> can be specified. During execution, a pointer to the <ref refid="structmd" kindref="compound">md</ref> object itself is passed to the external force function as the last argument. Under normal use, a call to <computeroutput>my_external_force()</computeroutput> function would compute a force on particle <computeroutput>i</computeroutput> that is a function of the positions and velocities of <computeroutput>i</computeroutput> and <computeroutput>partners</computeroutput>, and update the force vector <computeroutput></computeroutput>((md&lt;dim&gt;*) sys)-&gt;particles[i].F with this force. However, the external force function is not restricted to calculating and updating forces, but could modify the <ref refid="structmd" kindref="compound">md</ref> object in any way.</para>
<para>The macro <ref refid="macros_8libmd_8h_ae3d9f52a1a315303ad04f0576bd42a25_1ae3d9f52a1a315303ad04f0576bd42a25" kindref="member">SYS</ref> eases the referencing of member variables within <computeroutput>sys</computeroutput> within the <computeroutput>my_external_force()</computeroutput> function. For instance, <computeroutput></computeroutput>((md&lt;dim&gt;*) sys)-&gt;particles[i].F can be rewritten as <computeroutput>SYS-&gt;particles</computeroutput>[i].F.</para>
<para>Once an external force function has been defined, a function pointer pointing to it is added to the list of external force functions <computeroutput>md&lt;dim&gt;::f.extforces</computeroutput> through a call to the <ref refid="structexternalforces_a81e85285b5d21febef146fe13bdb50a5_1a81e85285b5d21febef146fe13bdb50a5" kindref="member">externalforces::add()</ref> member function of <ref refid="structmd_a2997460875452413182c56784f50edaf_1a2997460875452413182c56784f50edaf" kindref="member">md&lt;dim&gt;::f</ref>. Each added external force function is given a unique index, which is the return value of <computeroutput>md&lt;dim&gt;::f.add()</computeroutput>. The following command adds the function <computeroutput>my_external_force()</computeroutput> to an <computeroutput>md&lt;dim&gt;</computeroutput> instance named <computeroutput>sys</computeroutput>, and stores the associated index in <computeroutput>fidx:</computeroutput> <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="structmd" kindref="compound">md&lt;dim&gt;</ref><sp/>sys;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">ui<sp/>fidx<sp/>=<sp/>sys.<ref refid="structmd_a2997460875452413182c56784f50edaf_1a2997460875452413182c56784f50edaf" kindref="member">f</ref>.add(my_external_force&lt;dim&gt;);</highlight></codeline>
</programlisting> <emphasis>Particular</emphasis> forcetypes are obtained by combining an external force function indexed by <computeroutput>fidx</computeroutput> with a specific set of parameters, using the <ref refid="structmd_a0008f4806c077d79f3ebd03a13b8ddee_1a0008f4806c077d79f3ebd03a13b8ddee" kindref="member">md&lt;dim&gt;::add_forcetype</ref> function catalogued in the <ulink url="#md-forcetypedef">following subsection</ulink>.</para>
<sect4 id="md_doc_markdown_interactions_1autotoc_md6">
<title>Predefined external force functions</title>
<para><computeroutput>libmd</computeroutput> comes with two predefined external force functions, which illustrate the concept.</para>
<para><itemizedlist>
<listitem><para>The <ref refid="forces_8libmd_8cc_afdbadf91896c58754c50328fa20d2916_1afdbadf91896c58754c50328fa20d2916" kindref="member">DAMPING()</ref> function updates <computeroutput>SYS-&gt;particles</computeroutput>[i].F with a viscous drag force that is a function solely of the velocity of particle <computeroutput>i</computeroutput>. The corresponding force index is <computeroutput><ref refid="struct_e_x_t_f_o_r_c_e_ae0d69b9865d5f695184b9bd5bb549414_1ae0d69b9865d5f695184b9bd5bb549414abe9f35c74d55b423b9adebef5d0e0e88" kindref="member">EXTFORCE::DAMPING</ref></computeroutput>.</para>
</listitem><listitem><para>The <ref refid="forces_8libmd_8cc_ac068804729d4125f5c60e300c54e61c6_1ac068804729d4125f5c60e300c54e61c6" kindref="member">DISSIPATION()</ref> function updates <computeroutput>SYS-&gt;particles</computeroutput>[i].F with a force proportional to the velocity difference between <computeroutput>i</computeroutput> and each particle index in <computeroutput>particles</computeroutput>. The function is indexed by <ref refid="struct_e_x_t_f_o_r_c_e_ae0d69b9865d5f695184b9bd5bb549414_1ae0d69b9865d5f695184b9bd5bb549414aa47a3091b3ef6c44e82af557a11bd516" kindref="member">EXTFORCE::DISSIPATION</ref>.</para>
</listitem></itemizedlist>
</para>
</sect4>
</sect3>
<sect3 id="md_doc_markdown_interactions_1md-forcetypedef">
<title>Forcetypes</title>
<para>An external force function indexed by <computeroutput>fidx</computeroutput> is combined with specific values of parameters and a specific list of particles associated with each particle to create distinct <emphasis>forcetypes</emphasis>, which are instances of the <ref refid="structforcetype" kindref="compound">forcetype</ref> structure. These are stored in <computeroutput>md&lt;dim&gt;::network.forcelibrary[]</computeroutput>, a vector of <ref refid="structforcetype" kindref="compound">forcetype</ref> instances. Different forcetypes are indexed by their position in this vector.</para>
<para>Entries in the forcetype library are added, modified and removed using the following functions, which returns a <computeroutput>bool</computeroutput> indicating the success of the operation:</para>
<para><itemizedlist>
<listitem><para><ref refid="structmd_a0008f4806c077d79f3ebd03a13b8ddee_1a0008f4806c077d79f3ebd03a13b8ddee" kindref="member">md&lt;dim&gt;::add_forcetype</ref>(ui fidx, vector&lt;vector&lt;ui&gt;&gt; &amp;partnerlist, vector&lt;ldf&gt; &amp;parameters) creates a forcetype from the external force function indexed by <computeroutput>fidx</computeroutput> with the given parameters. The <computeroutput>partnerlist</computeroutput> is either empty, or points to a list of lists of partner indices, so that <computeroutput></computeroutput>(&amp;partnerlist)[i] contains the partners of particle <computeroutput>i</computeroutput> to be passed to the external force function. The return value is the index of the forcetype in <computeroutput>md&lt;dim&gt;::network.forcelibrary[]</computeroutput>, which we will call <computeroutput>ftype</computeroutput>.</para>
</listitem><listitem><para><ref refid="structmd_a765213fe1e96156bae8b60687b763543_1a765213fe1e96156bae8b60687b763543" kindref="member">md&lt;dim&gt;::mod_forcetype</ref>(ui ftype, ui fidx, vector&lt;vector&lt;ui&gt;&gt; &amp;partnerlist, vector&lt;ldf&gt; &amp;parameters) replaces the external force function and partner list of the forcetype indexed by <computeroutput>ftype</computeroutput>.</para>
</listitem><listitem><para><ref refid="structmd_adb0b0c0ea9c035858eadac1e2d0e1ab2_1adb0b0c0ea9c035858eadac1e2d0e1ab2" kindref="member">md&lt;dim&gt;::rem_forcetype(ui ftype)</ref> removes the interaction indexed by <computeroutput>ftype</computeroutput>.</para>
</listitem></itemizedlist>
</para>
<para>Once a forcetype entry has been created, it still needs to be assigned to a particle to influence the dynamics of that particle. Forcetype assignment is handled by the following set of functions:</para>
<para><itemizedlist>
<listitem><para><ref refid="structmd_a689eedf4ef9bb0693560854d4b846eb7_1a689eedf4ef9bb0693560854d4b846eb7" kindref="member">md&lt;dim&gt;::assign_forcetype(ui i, ui ftype)</ref> assigns <computeroutput>ftype</computeroutput> to particle <computeroutput>i</computeroutput>.</para>
</listitem><listitem><para><ref refid="structmd_a2eb87929ef4c0a1bb1eebf8b310153fa_1a2eb87929ef4c0a1bb1eebf8b310153fa" kindref="member">md&lt;dim&gt;::assign_all_forcetype(ui ftype)</ref> assigns <computeroutput>ftype</computeroutput> to all particles.</para>
</listitem><listitem><para>md&lt;dim&gt;::unassign_forcetype(ui ftype) and md&lt;dim&gt;::unassign_all_forcetype(ui ftype, ui i) remove the assignment of <computeroutput>ftype</computeroutput> from one or all particles.</para>
</listitem></itemizedlist>
</para>
<para>Finally, the function <ref refid="structmd_a9aabb9439ebd5dd2bd310adad84daac8_1a9aabb9439ebd5dd2bd310adad84daac8" kindref="member">md&lt;dim&gt;::clear_all_assigned_forcetype()</ref> is useful to clear all assignments to forcetypes from all particles, although it does not remove the forcetypes themselves. </para>
</sect3>
</sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
