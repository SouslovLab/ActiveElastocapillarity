.TH "md< dim >" 3 "Thu Sep 3 2020" "Version -0." "libmd" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md< dim > \- This structure defines the molecular dynamics simulation\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <libmd\&.h>\fP
.PP
Inherited by \fBmpmd< dim >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBmd\fP (\fBui\fP particlenr=0)"
.br
.RI "Constructor\&. "
.ti -1c
.RI "void \fBinit\fP (\fBui\fP particlenr)"
.br
.RI "Copy of the particle number constructor\&. "
.ti -1c
.RI "\fBldf\fP \fBdap\fP (\fBui\fP d, \fBldf\fP ad)"
.br
.RI "Manipulate particle distances with respect to periodic boundary conditions\&. "
.ti -1c
.RI "\fBldf\fP \fBdistsq\fP (\fBui\fP p1, \fBui\fP p2)"
.br
.RI "Calculate distances between two particles (squared) "
.ti -1c
.RI "\fBldf\fP \fBdistsq\fP (\fBldf\fP x1[dim], \fBldf\fP x2[dim])"
.br
.RI "Calculate distances between two particles (squared) ldf \fBdistsq(ui p1,ldf x2[dim])\fP; ///< Calculate distances between two particles (squared) "
.ti -1c
.RI "\fBldf\fP \fBdistsq\fP (\fBui\fP p1, \fBldf\fP x2[dim])"
.br
.RI "Calculate distances between two particles (squared) "
.ti -1c
.RI "\fBldf\fP \fBdistsq\fP (\fBldf\fP x1[dim], \fBui\fP p2)"
.br
.RI "Calculate distances between two particles (squared) "
.ti -1c
.RI "\fBldf\fP \fBdd\fP (\fBui\fP d, \fBui\fP p1, \fBui\fP p2)"
.br
.RI "Calculate difference in particle positions in certain dimension i by particle index\&. "
.ti -1c
.RI "\fBldf\fP \fBdd\fP (\fBui\fP d, \fBldf\fP x1[dim], \fBldf\fP x2[dim])"
.br
.RI "Calculate difference in particle positions in certain dimension i by particle index\&. "
.ti -1c
.RI "\fBldf\fP \fBdd\fP (\fBui\fP d, \fBui\fP p1, \fBldf\fP x2[dim])"
.br
.RI "Calculate difference in particle positions in certain dimension i by particle index\&. "
.ti -1c
.RI "\fBldf\fP \fBdd\fP (\fBui\fP d, \fBldf\fP x1[dim], \fBui\fP p2)"
.br
.RI "Calculate difference in particle positions in certain dimension i by particle index\&. "
.ti -1c
.RI "\fBldf\fP \fBdv\fP (\fBui\fP d, \fBui\fP p1, \fBui\fP p2)"
.br
.RI "Calculate difference in particle velocities in certain dimension i by particle index\&. "
.ti -1c
.RI "void \fBinteractions\fP (\fBui\fP i, std::vector< std::pair< \fBui\fP, \fBui\fP >> &table)"
.br
.RI "Dump interactions of a certain particle into a table\&. "
.ti -1c
.RI "void \fBall_interactions\fP (std::vector< std::pair< \fBui\fP, \fBui\fP >> &table)"
.br
.RI "Dump all interaction into a table\&. "
.ti -1c
.RI "\fBui\fP \fBadd_interaction\fP (\fBui\fP potential, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Add type interaction rule\&. "
.ti -1c
.RI "\fBui\fP \fBadd_interaction\fP (\fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Add type interaction rule\&. "
.ti -1c
.RI "bool \fBmod_interaction\fP (\fBui\fP interaction, \fBui\fP potential, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Modify type interaction rule\&. "
.ti -1c
.RI "bool \fBmod_interaction\fP (\fBui\fP interaction, \fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Modify type interaction rule\&. "
.ti -1c
.RI "bool \fBrem_interaction\fP (\fBui\fP interaction)"
.br
.RI "Delete type interaction rule\&. "
.ti -1c
.RI "bool \fBadd_typeinteraction\fP (\fBui\fP type1, \fBui\fP type2, \fBui\fP interaction)"
.br
.RI "Add type interaction rule\&. "
.ti -1c
.RI "bool \fBmod_typeinteraction\fP (\fBui\fP type1, \fBui\fP type2, \fBui\fP interaction)"
.br
.RI "Modify type interaction rule\&. "
.ti -1c
.RI "void \fBmad_typeinteraction\fP (\fBui\fP type1, \fBui\fP type2, \fBui\fP interaction)"
.br
.RI "Force add/mod type interaction rule\&. "
.ti -1c
.RI "bool \fBadd_typeinteraction\fP (\fBui\fP type1, \fBui\fP type2, \fBui\fP potential, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Add type interaction rule\&. "
.ti -1c
.RI "bool \fBadd_typeinteraction\fP (\fBui\fP type1, \fBui\fP type2, \fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Add type interaction rule\&. "
.ti -1c
.RI "bool \fBmod_typeinteraction\fP (\fBui\fP type1, \fBui\fP type2, \fBui\fP potential, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Modify type interaction rule\&. "
.ti -1c
.RI "bool \fBmod_typeinteraction\fP (\fBui\fP type1, \fBui\fP type2, \fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Modify type interaction rule\&. "
.ti -1c
.RI "void \fBmad_typeinteraction\fP (\fBui\fP type1, \fBui\fP type2, \fBui\fP potential, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Force add/mod type interaction rule\&. "
.ti -1c
.RI "void \fBmad_typeinteraction\fP (\fBui\fP type1, \fBui\fP type2, \fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Force add/mod type interaction rule\&. "
.ti -1c
.RI "bool \fBrem_typeinteraction\fP (\fBui\fP type1, \fBui\fP type2)"
.br
.RI "Delete type interaction rule\&. "
.ti -1c
.RI "\fBui\fP \fBadd_sptype\fP ()"
.br
.RI "Add superparticletype\&. "
.ti -1c
.RI "bool \fBrem_sptype\fP (\fBui\fP spt)"
.br
.RI "Delete superparticletype\&. "
.ti -1c
.RI "bool \fBadd_sp_interaction\fP (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"
.br
.RI "Add superparticle interaction rule\&. "
.ti -1c
.RI "bool \fBmod_sp_interaction\fP (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"
.br
.RI "Modify superparticle interaction rule\&. "
.ti -1c
.RI "\fBui\fP \fBmad_sp_interaction\fP (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"
.br
.RI "Force add/mod superparticle interaction rule\&. "
.ti -1c
.RI "bool \fBadd_sp_interaction\fP (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Add superparticle interaction rule\&. "
.ti -1c
.RI "bool \fBadd_sp_interaction\fP (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Add superparticle interaction rule\&. "
.ti -1c
.RI "bool \fBmod_sp_interaction\fP (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Modify superparticle interaction rule\&. "
.ti -1c
.RI "bool \fBmod_sp_interaction\fP (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Modify superparticle interaction rule\&. "
.ti -1c
.RI "\fBui\fP \fBmad_sp_interaction\fP (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Force add/mod superparticle interaction rule\&. "
.ti -1c
.RI "\fBui\fP \fBmad_sp_interaction\fP (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Force add/mod superparticle interaction rule\&. "
.ti -1c
.RI "bool \fBrem_sp_interaction\fP (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2)"
.br
.RI "Delete superparticle interaction rule\&. "
.ti -1c
.RI "\fBui\fP \fBadd_forcetype\fP (\fBui\fP force, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Add force type\&. "
.ti -1c
.RI "\fBui\fP \fBadd_forcetype\fP (\fBui\fP force, std::vector< std::vector< \fBui\fP >> &plist, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Add force type with plist\&. "
.ti -1c
.RI "bool \fBmod_forcetype\fP (\fBui\fP ftype, \fBui\fP force, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Modify force type\&. "
.ti -1c
.RI "bool \fBmod_forcetype\fP (\fBui\fP ftype, \fBui\fP force, std::vector< std::vector< \fBui\fP >> &plist, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Modify force type plist\&. "
.ti -1c
.RI "bool \fBrem_forcetype\fP (\fBui\fP ftype)"
.br
.RI "Delete force type\&. "
.ti -1c
.RI "bool \fBassign_forcetype\fP (\fBui\fP i, \fBui\fP ftype)"
.br
.RI "Assign force type to particle\&. "
.ti -1c
.RI "void \fBassign_all_forcetype\fP (\fBui\fP ftype)"
.br
.RI "Assign force type to all particles\&. "
.ti -1c
.RI "bool \fBunassign_forcetype\fP (\fBui\fP i, \fBui\fP ftype)"
.br
.RI "Unassign force type to particle\&. "
.ti -1c
.RI "void \fBunassign_all_forcetype\fP (\fBui\fP ftype)"
.br
.RI "Unassign force type to all particles\&. "
.ti -1c
.RI "void \fBclear_all_assigned_forcetype\fP ()"
.br
.RI "Clear all assigned forces\&. "
.ti -1c
.RI "\fBui\fP \fBadd_hook\fP (\fBui\fP nohook, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Add a hook\&. "
.ti -1c
.RI "bool \fBmod_hook\fP (\fBui\fP htype, \fBui\fP nohook, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Modify a hook\&. "
.ti -1c
.RI "bool \fBrem_hook\fP (\fBui\fP htype)"
.br
.RI "Remove a hook\&. "
.ti -1c
.RI "bool \fBrun_hook\fP (\fBui\fP htype)"
.br
.RI "Run a certain hook\&. "
.ti -1c
.RI "void \fBrun_hooks\fP ()"
.br
.RI "Run all hooks\&. "
.ti -1c
.RI "\fBldf\fP \fBget_rco\fP (\fBui\fP i, \fBui\fP j)"
.br
.RI "Gets the cuttoff radius for a certain pair of particles\&. "
.ti -1c
.RI "\fBldf\fP \fBget_rco\fP (\fBui\fP interaction)"
.br
.RI "Gets the cuttoff radius for a certain interaction\&. "
.ti -1c
.RI "void \fBset_rco\fP (\fBldf\fP rco)"
.br
.RI "Sets the cuttoff radius\&. "
.ti -1c
.RI "void \fBset_rco\fP (\fBui\fP interaction, \fBldf\fP rco)"
.br
.RI "Sets the cuttoff radius\&. "
.ti -1c
.RI "void \fBset_ssz\fP (\fBldf\fP ssz)"
.br
.RI "Sets the skin size radius and its square\&. "
.ti -1c
.RI "void \fBset_reserve\fP (\fBldf\fP ssz)"
.br
.RI "Set reserve memory according to skin size\&. "
.ti -1c
.RI "void \fBset_reserve\fP (\fBldf\fP ssz, \fBui\fP M)"
.br
.RI "Set reserve memory according to skin size and some arbitrary number of particles\&. "
.ti -1c
.RI "void \fBset_type\fP (\fBui\fP p, \fBui\fP newtype)"
.br
.RI "Update the type associated with particle p\&. "
.ti -1c
.RI "void \fBset_index_method\fP (\fBui\fP method)"
.br
.RI "Set indexmethod\&. "
.ti -1c
.RI "void \fBindex\fP ()"
.br
.RI "Find neighbors\&. "
.ti -1c
.RI "bool \fBtest_index\fP ()"
.br
.RI "Test if we need to run the indexing algorithm\&. "
.ti -1c
.RI "void \fBthread_index_stick\fP (\fBui\fP i)"
.br
.RI "Save the particle position at indexing\&. "
.ti -1c
.RI "\fBui\fP \fBkdtree_build\fP (\fBui\fP first, \fBui\fP last, \fBui\fP level)"
.br
.RI "k-d tree indexing algorithm: tree build function (recursive) "
.ti -1c
.RI "void \fBkdtree_index\fP (\fBui\fP first1, \fBui\fP last1, \fBui\fP first2, \fBui\fP last2)"
.br
.RI "k-d tree indexing algorithm: neighbor finder (recursive) "
.ti -1c
.RI "void \fBkdtree\fP ()"
.br
.RI "k-d tree indexing algorithm "
.ti -1c
.RI "void \fBcell\fP ()"
.br
.RI "Cell indexing algorithm\&. "
.ti -1c
.RI "void \fBthread_cell\fP (\fBui\fP c)"
.br
.RI "Cell indexer for cell c (thread) "
.ti -1c
.RI "void \fBbruteforce\fP ()"
.br
.RI "Bruteforce indexing algorithm\&. "
.ti -1c
.RI "void \fBskinner\fP (\fBui\fP i, \fBui\fP j, \fBldf\fP sszsq)"
.br
.RI "Places interactionneighbor in skin\&. "
.ti -1c
.RI "void \fBthread_clear_forces\fP (\fBui\fP i)"
.br
.RI "Clear forces for particle i\&. "
.ti -1c
.RI "void \fBthread_calc_pot_forces\fP (\fBui\fP i)"
.br
.RI "Calculate the forces for particle i>j with atomics\&. "
.ti -1c
.RI "void \fBthread_calc_ext_forces\fP (\fBui\fP i)"
.br
.RI "Calculate the forces for particle i>j with atomics\&. "
.ti -1c
.RI "virtual void \fBcalc_forces\fP ()"
.br
.RI "Calculate the forces between interacting particles\&. "
.ti -1c
.RI "virtual void \fBrecalc_forces\fP ()"
.br
.RI "Recalculate the forces between interacting particles for Velocity Verlet\&. "
.ti -1c
.RI "void \fBupdate_boundaries\fP ()"
.br
.RI "Shifts the periodic boxes appropriately for sheared BC\&. "
.ti -1c
.RI "void \fBperiodicity\fP ()"
.br
.RI "Called after integration to keep the particle within the defined boundaries\&. "
.ti -1c
.RI "void \fBthread_periodicity\fP (\fBui\fP i)"
.br
.RI "Apply periodicity to one particle only\&. "
.ti -1c
.RI "void \fBthread_periodicity\fP (\fBldf\fP x[dim])"
.br
.RI "Apply periodicity to one particle only\&. "
.ti -1c
.RI "void \fBthread_seuler\fP (\fBui\fP i)"
.br
.RI "Symplectic euler integrator (threaded) "
.ti -1c
.RI "void \fBthread_vverlet_x\fP (\fBui\fP i)"
.br
.RI "Velocity verlet integrator for position (threaded) "
.ti -1c
.RI "void \fBthread_vverlet_dx\fP (\fBui\fP i)"
.br
.RI "Velocity verlet integrator for velocity (threaded) "
.ti -1c
.RI "void \fBthread_first_order\fP (\fBui\fP i)"
.br
.RI "First order (Euler) integrator (threaded) "
.ti -1c
.RI "void \fBthread_overdamped\fP (\fBui\fP i)"
.br
.RI "First order (Euler) integrator for overdamped dynamics (threaded) "
.ti -1c
.RI "virtual void \fBintegrate\fP ()"
.br
.RI "Integrate particle trajectoriess\&. "
.ti -1c
.RI "void \fBtimestep\fP ()"
.br
.RI "Do one timestep\&. "
.ti -1c
.RI "void \fBtimesteps\fP (\fBui\fP k)"
.br
.RI "Do multiple timesteps\&. "
.ti -1c
.RI "void \fBimport_pos\fP (\fBldf\fP *x)"
.br
.RI "Load positions from arrays\&. "
.ti -1c
.RI "template<typename\&.\&.\&. arg> void \fBimport_pos\fP (\fBldf\fP *x, arg\&.\&.\&.argv)"
.br
.RI "Load positions from arrays\&. "
.ti -1c
.RI "void \fBimport_pos\fP (\fBui\fP i, \fBldf\fP x)"
.br
.RI "Load position for i from value\&. "
.ti -1c
.RI "template<typename\&.\&.\&. arg> void \fBimport_pos\fP (\fBui\fP i, \fBldf\fP x, arg\&.\&.\&.argv)"
.br
.RI "Load position for i from value\&. "
.ti -1c
.RI "void \fBimport_vel\fP (\fBldf\fP *dx)"
.br
.RI "Load velocity from arrays\&. "
.ti -1c
.RI "template<typename\&.\&.\&. arg> void \fBimport_vel\fP (\fBldf\fP *dx, arg\&.\&.\&.argv)"
.br
.RI "Load velocity from arrays\&. "
.ti -1c
.RI "void \fBimport_vel\fP (\fBui\fP i, \fBldf\fP dx)"
.br
.RI "Load velocity for i from value\&. "
.ti -1c
.RI "template<typename\&.\&.\&. arg> void \fBimport_vel\fP (\fBui\fP i, \fBldf\fP dx, arg\&.\&.\&.argv)"
.br
.RI "Load velocity for i from value\&. "
.ti -1c
.RI "void \fBimport_force\fP (\fBldf\fP *F)"
.br
.RI "Load forces from arrays\&. "
.ti -1c
.RI "template<typename\&.\&.\&. arg> void \fBimport_force\fP (\fBldf\fP *F, arg\&.\&.\&.argv)"
.br
.RI "Load forces from arrays\&. "
.ti -1c
.RI "void \fBimport_force\fP (\fBui\fP i, \fBldf\fP F)"
.br
.RI "Load position for i from value\&. "
.ti -1c
.RI "template<typename\&.\&.\&. arg> void \fBimport_force\fP (\fBui\fP i, \fBldf\fP F, arg\&.\&.\&.argv)"
.br
.RI "Load position for i from value\&. "
.ti -1c
.RI "void \fBexport_pos\fP (\fBldf\fP *x)"
.br
.RI "Save positions from arrays\&. "
.ti -1c
.RI "template<typename\&.\&.\&. arg> void \fBexport_pos\fP (\fBldf\fP *x, arg\&.\&.\&.argv)"
.br
.RI "Save positions to arrays\&. "
.ti -1c
.RI "void \fBexport_pos\fP (\fBui\fP i, \fBldf\fP &x)"
.br
.RI "Save positions from arrays\&. "
.ti -1c
.RI "template<typename\&.\&.\&. arg> void \fBexport_pos\fP (\fBui\fP i, \fBldf\fP &x, arg\&.\&.\&.argv)"
.br
.RI "Save positions to arrays\&. "
.ti -1c
.RI "void \fBexport_vel\fP (\fBldf\fP *dx)"
.br
.RI "Save velocity from arrays\&. "
.ti -1c
.RI "template<typename\&.\&.\&. arg> void \fBexport_vel\fP (\fBldf\fP *dx, arg\&.\&.\&.argv)"
.br
.RI "Save velocity to arrays\&. "
.ti -1c
.RI "void \fBexport_vel\fP (\fBui\fP i, \fBldf\fP &dx)"
.br
.RI "Save positions from arrays\&. "
.ti -1c
.RI "template<typename\&.\&.\&. arg> void \fBexport_vel\fP (\fBui\fP i, \fBldf\fP &dx, arg\&.\&.\&.argv)"
.br
.RI "Save positions to arrays\&. "
.ti -1c
.RI "void \fBexport_force\fP (\fBldf\fP *F)"
.br
.RI "Save forces from arrays\&. "
.ti -1c
.RI "template<typename\&.\&.\&. arg> void \fBexport_force\fP (\fBldf\fP *F, arg\&.\&.\&.argv)"
.br
.RI "Save forces to arrays\&. "
.ti -1c
.RI "void \fBexport_force\fP (\fBui\fP i, \fBldf\fP &F)"
.br
.RI "Save forces from arrays\&. "
.ti -1c
.RI "template<typename\&.\&.\&. arg> void \fBexport_force\fP (\fBui\fP i, \fBldf\fP &F, arg\&.\&.\&.argv)"
.br
.RI "Save forces to arrays\&. "
.ti -1c
.RI "\fBldf\fP \fBdirect_readout_x\fP (\fBui\fP d, \fBui\fP i)"
.br
.RI "Directly readout a position\&. "
.ti -1c
.RI "\fBldf\fP \fBdirect_readout_dx\fP (\fBui\fP d, \fBui\fP i)"
.br
.RI "Directly readout a velocity\&. "
.ti -1c
.RI "\fBldf\fP \fBdirect_readout_F\fP (\fBui\fP d, \fBui\fP i)"
.br
.RI "Directly readout a forces\&. "
.ti -1c
.RI "\fBldf\fP \fBdirect_readout\fP (\fBui\fP d, \fBui\fP i, \fBuc\fP type)"
.br
.RI "Directly readout a position'x'/velocity'v'/forces'F'\&. "
.ti -1c
.RI "\fBldf\fP \fBdirect_readout\fP (\fBui\fP i, \fBuc\fP type)"
.br
.RI "Directly readout a position'x'/velocity'v'/forces'F'\&. "
.ti -1c
.RI "void \fBfix_particle\fP (\fBui\fP i, bool fix)"
.br
.RI "Fix a particle\&. "
.ti -1c
.RI "void \fBfix_sp\fP (\fBui\fP spi, bool fix)"
.br
.RI "Fix a super particles\&. "
.ti -1c
.RI "\fBui\fP \fBclone_particle\fP (\fBui\fP i, \fBldf\fP x[dim])"
.br
.RI "Clone a particle and translate\&. "
.ti -1c
.RI "\fBui\fP \fBclone_sp\fP (\fBui\fP spi, \fBldf\fP x[dim])"
.br
.RI "Clone a superparticle and translate\&. "
.ti -1c
.RI "void \fBtranslate_particle\fP (\fBui\fP i, \fBldf\fP x[dim])"
.br
.RI "Translate (or move) a particle\&. "
.ti -1c
.RI "void \fBtranslate_sp\fP (\fBui\fP spi, \fBldf\fP x[dim])"
.br
.RI "Translate (or move) a super particle\&. "
.ti -1c
.RI "void \fBdrift_particle\fP (\fBui\fP i, \fBldf\fP dx[dim])"
.br
.RI "Add velocity to a particle\&. "
.ti -1c
.RI "void \fBdrift_sp\fP (\fBui\fP spi, \fBldf\fP dx[dim])"
.br
.RI "Add velocity to a super particle (all particles the same) "
.ti -1c
.RI "void \fBheat_particle\fP (\fBui\fP i, \fBldf\fP lambda)"
.br
.RI "Multiply velocity vector of a particle with a scalar\&. "
.ti -1c
.RI "void \fBheat_sp\fP (\fBui\fP spi, \fBldf\fP lambda)"
.br
.RI "Multiply velocity vectors of a super particle with a scalar (all particles the same) "
.ti -1c
.RI "void \fBset_position_sp\fP (\fBui\fP spi, \fBldf\fP x[dim])"
.br
.RI "Get center of mass of super particle\&. "
.ti -1c
.RI "void \fBset_velocity_sp\fP (\fBui\fP spi, \fBldf\fP dx[dim])"
.br
.RI "Assign velocity to a super particle (all particles the same) "
.ti -1c
.RI "void \fBget_position_sp\fP (\fBui\fP spi, \fBldf\fP x[dim])"
.br
.RI "Get center of mass of super particle\&. "
.ti -1c
.RI "void \fBget_velocity_sp\fP (\fBui\fP spi, \fBldf\fP dx[dim])"
.br
.RI "Get average velocity of a super particle\&. "
.ti -1c
.RI "\fBui\fP \fBadd_sp\fP (\fBui\fP sptype)"
.br
.RI "Add a superparticle\&. "
.ti -1c
.RI "bool \fBrem_sp\fP (\fBui\fP spi)"
.br
.RI "Remove a superparticle (i\&.e\&. the structure, not the particles) "
.ti -1c
.RI "bool \fBrem_sp_particles\fP (\fBui\fP spi)"
.br
.RI "Remove all particles in a superparticle\&. "
.ti -1c
.RI "\fBui\fP \fBsp_ingest\fP (\fBui\fP spi, \fBui\fP i, \fBui\fP idx=\fBUI_MAX\fP)"
.br
.RI "Add a particle to a superparticle\&. "
.ti -1c
.RI "bool \fBsp_dispose\fP (\fBui\fP i)"
.br
.RI "Remove a particle from a superparticle\&. "
.ti -1c
.RI "bool \fBsp_dispose_idx\fP (\fBui\fP spi, \fBui\fP idx)"
.br
.RI "Remove a particle from a superparticle\&. "
.ti -1c
.RI "\fBui\fP \fBsp_pid\fP (\fBui\fP spi, \fBui\fP idx)"
.br
.RI "Reverse lookup of particle id in superparticle\&. "
.ti -1c
.RI "\fBui\fP \fBadd_particle\fP (\fBldf\fP mass=1\&.0, \fBui\fP ptype=0, bool fixed=false)"
.br
.RI "Add a particle to the system\&. "
.ti -1c
.RI "\fBui\fP \fBadd_particle\fP (\fBldf\fP x[dim], \fBldf\fP mass=1\&.0, \fBui\fP ptype=0, bool fixed=false)"
.br
.RI "Add a particle to the system at certain position\&. "
.ti -1c
.RI "\fBui\fP \fBadd_particle\fP (\fBldf\fP x[dim], \fBldf\fP dx[dim], \fBldf\fP mass=1\&.0, \fBui\fP ptype=0, bool fixed=false)"
.br
.RI "Add a particle to the system at certain position with certain velocity\&. "
.ti -1c
.RI "\fBui\fP \fBadd_particle\fP (\fBldf\fP x[dim], \fBldf\fP dx[dim], \fBuc\fP \fBbcond\fP[dim], \fBldf\fP mass=1\&.0, \fBui\fP ptype=0, bool fixed=false, bool bconded=true)"
.br
.RI "Add a particle to the system at certain position with certain velocity with certain bconds\&. "
.ti -1c
.RI "void \fBrem_particle\fP (\fBui\fP i)"
.br
.RI "Remove a particle from the system\&. "
.ti -1c
.RI "void \fBclear\fP ()"
.br
.RI "Clear all particles and interactions\&. "
.ti -1c
.RI "void \fBset_damping\fP (\fBldf\fP coefficient)"
.br
.RI "Enables damping and sets damping coefficient\&. "
.ti -1c
.RI "bool \fBunset_damping\fP ()"
.br
.RI "Disables damping\&. "
.ti -1c
.RI "virtual void \fBset_langevin\fP (\fBldf\fP \fBT\fP, \fBldf\fP gamma)"
.br
.RI "Enables Langevin thermostat (and damping) and sets T and gamma (does not use metric) "
.ti -1c
.RI "bool \fBunset_langevin\fP ()"
.br
.RI "Disable Langevin thermostat\&. "
.ti -1c
.RI "void \fBset_overdamped\fP (\fBldf\fP coefficient)"
.br
.RI "Enable overdamped dynamics (with First oder integration) "
.ti -1c
.RI "bool \fBunset_overdamped\fP ()"
.br
.RI "Disable overdamped dynamics\&. "
.ti -1c
.RI "void \fBupdate_skins\fP (\fBui\fP p1, \fBui\fP p2)"
.br
.RI "Modify skins after adding/modifying/removing bond\&. "
.ti -1c
.RI "bool \fBadd_bond\fP (\fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"
.br
.RI "Add a bond\&. "
.ti -1c
.RI "bool \fBmod_bond\fP (\fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"
.br
.RI "Modify a bond\&. "
.ti -1c
.RI "void \fBmad_bond\fP (\fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"
.br
.RI "Force add/modify bond\&. "
.ti -1c
.RI "bool \fBadd_bond\fP (\fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Add a bond\&. "
.ti -1c
.RI "bool \fBmod_bond\fP (\fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Modify a bond\&. "
.ti -1c
.RI "void \fBmad_bond\fP (\fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Force add/modify bond\&. "
.ti -1c
.RI "bool \fBrem_bond\fP (\fBui\fP p1, \fBui\fP p2)"
.br
.RI "Remove a bond from the system\&. "
.ti -1c
.RI "void \fBassign_unique_types\fP (\fBui\fP p1, \fBui\fP p2)"
.br
.RI "Assign unique types to particles, modify lookup\&. "
.ti -1c
.RI "void \fBadd_spring\fP (\fBui\fP p1, \fBui\fP p2, \fBldf\fP springconstant, \fBldf\fP l0)"
.br
.RI "Add a harmonic bond to the system\&. "
.ti -1c
.RI "bool \fBadd_sp_bond\fP (\fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"
.br
.RI "Add a superparticle bond\&. "
.ti -1c
.RI "bool \fBmod_sp_bond\fP (\fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"
.br
.RI "Modify a superparticle bond\&. "
.ti -1c
.RI "void \fBmad_sp_bond\fP (\fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"
.br
.RI "Force add/modify superparticle bond\&. "
.ti -1c
.RI "bool \fBadd_sp_bond\fP (\fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Add a superparticle bond\&. "
.ti -1c
.RI "bool \fBmod_sp_bond\fP (\fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Modify a superparticle bond\&. "
.ti -1c
.RI "void \fBmad_sp_bond\fP (\fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > &parameters)"
.br
.RI "Force add/modify superparticle bond\&. "
.ti -1c
.RI "bool \fBrem_sp_bond\fP (\fBui\fP p1, \fBui\fP p2)"
.br
.RI "Remove a superparticle bond from the system\&. "
.ti -1c
.RI "\fBui\fP \fBclone_sptype\fP (\fBui\fP sp)"
.br
.RI "Make a new sptype for superparticle sp if it is not unique to sp\&. "
.ti -1c
.RI "void \fBset_bcond\fP (\fBuc\fP \fBbcond\fP[dim])"
.br
.RI "Set the global boundary conditions\&. "
.ti -1c
.RI "void \fBset_pbcond\fP (\fBui\fP i, \fBuc\fP \fBbcond\fP[dim], bool toggle=true)"
.br
.RI "Set the boundary conditions for particle i\&. "
.ti -1c
.RI "void \fBset_spbcond\fP (\fBui\fP spi, \fBuc\fP \fBbcond\fP[dim], bool toggle=true)"
.br
.RI "Set the boundary conditions for superparticle spi\&. "
.ti -1c
.RI "\fBldf\fP \fBthread_H\fP (\fBui\fP i)"
.br
.RI "Measure Hamiltonian for particle i\&. "
.ti -1c
.RI "virtual \fBldf\fP \fBthread_T\fP (\fBui\fP i)"
.br
.RI "Measure kinetic energy for particle i\&. "
.ti -1c
.RI "virtual \fBldf\fP \fBthread_V\fP (\fBui\fP i, bool higher_index_only=false)"
.br
.RI "Measure potential energy for particle i\&. "
.ti -1c
.RI "\fBldf\fP \fBH\fP ()"
.br
.RI "Measure Hamiltonian\&. "
.ti -1c
.RI "\fBldf\fP \fBT\fP ()"
.br
.RI "Measure kinetic energy\&. "
.ti -1c
.RI "\fBldf\fP \fBV\fP ()"
.br
.RI "Measure potential energy\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBui\fP \fBN\fP"
.br
.RI "Number of particles\&. "
.ti -1c
.RI "\fBbox\fP< dim > \fBsimbox\fP"
.br
.RI "Simulation box\&. "
.ti -1c
.RI "\fBbcond\fP< dim > \fBboundary\fP"
.br
.RI "Boundary conditions functor\&. "
.ti -1c
.RI "std::vector< \fBparticle\fP< dim > > \fBparticles\fP"
.br
.RI "Particle array\&. "
.ti -1c
.RI "\fBinteract\fP \fBnetwork\fP"
.br
.RI "Interaction network\&. "
.ti -1c
.RI "\fBindexer\fP< dim > \fBindexdata\fP"
.br
.RI "Data structure for indexing\&. "
.ti -1c
.RI "\fBpairpotentials\fP \fBv\fP"
.br
.RI "Pair potential functor\&. "
.ti -1c
.RI "\fBexternalforces\fP< dim > \fBf\fP"
.br
.RI "External forces functor\&. "
.ti -1c
.RI "\fBhooker\fP< dim > \fBhooks\fP"
.br
.RI "Hook functor\&. "
.ti -1c
.RI "\fBintegrators\fP \fBintegrator\fP"
.br
.RI "Integration method\&. "
.ti -1c
.RI "\fBvariadic_vars\fP< dim > \fBvvars\fP"
.br
.RI "Bunch of variables for variadic functions\&. "
.ti -1c
.RI "\fBadditional_vars\fP< dim > \fBavars\fP"
.br
.RI "Bunch of additonal variables\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<ui dim>
.br
struct md< dim >"
This structure defines the molecular dynamics simulation\&. 
.PP
Definition at line 375 of file libmd\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<ui dim> \fBmd\fP< dim >::\fBmd\fP (\fBui\fP particlenr = \fC0\fP)"

.PP
Constructor\&. Constructor for the md structure\&. The default number of particles is zero\&. Calls \fBinit()\fP\&.
.PP
Definition at line 6 of file md\&.libmd\&.cc\&.
.PP
.nf
7 {
13     init(particlenr);
14 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<ui dim> bool \fBmd\fP< dim >::add_bond (\fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"

.PP
Add a bond\&. This function adds a bond between particles \fCp1\fP and \fCp2\fP of previously-defined interaction type \fCinteraction\fP\&. (See the \fBInteractions\fP documentation for more information on interaction types\&.) 
.br

.br
 Does nothing and returns false if one of the following holds: 
.PD 0

.IP "\(bu" 2
an interaction already exists between \fCp1\fP and \fCp2\fP, 
.IP "\(bu" 2
the interaction specified by the third argument does not exist or was previously removed\&. 
.PP
Otherwise, creates a bond of the specified type between \fCp1\fP and \fCp2\fP, and returns \fCtrue\fP\&.
.PP
Definition at line 42 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
43 {
59     if (network\&.lookup\&.count(network\&.hash(particles[p1]\&.type,particles[p2]\&.type)))
60         return false;
61     else if(interaction>=network\&.library\&.size())
62     {
63         WARNING("interaction %d does not exist", interaction);
64         return false;
65     }
66     else if(network\&.free_library_slots\&.count(interaction))
67     {
68         WARNING("interaction %d was previously removed", interaction);
69         return false;
70     }
71     else
72     {   assign_unique_types(p1, p2);
73         network\&.lookup[network\&.hash(particles[p1]\&.type,particles[p2]\&.type)]=interaction;
74         update_skins(p1,p2);
75         return true;
76     }
77 }
.fi
.PP
References WARNING\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::add_bond (\fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > & parameters)"

.PP
Add a bond\&. This function adds a bond between particles \fCp1\fP and \fCp2\fP with the potential type and parameters specified in the arguments\&. (See the \fBInteractions\fP documentation for more information on potential types and passing parameters\&.) 
.br

.br
 Does nothing if an interaction already exists between \fCp1\fP and \fCp2\fP, and returns \fCfalse\fP\&. Otherwise, creates a bond of the specified type between \fCp1\fP and \fCp2\fP, and returns \fCtrue\fP\&.
.PP
Definition at line 130 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
131 {
142     if (!network\&.lookup\&.count(network\&.hash(particles[p1]\&.type,particles[p2]\&.type)))
143     {   mad_bond(p1, p2, add_interaction(potential, parameters));
144         return true;
145     }
146     else
147         return false;
148 }
.fi
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::add_forcetype (\fBui\fP force, std::vector< \fBldf\fP > & parameters)"

.PP
Add force type\&. This function adds a new forcetype, of the given type and with the given parameters, to \fCnetwork\&.forcelibrary[]\fP and returns its index\&.
.PP
Definition at line 512 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
513 {
517     forcetype temp(force,parameters);
518     network\&.forcelibrary\&.push_back(temp);
519     return network\&.forcelibrary\&.size()-1;
520 }
.fi
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::add_forcetype (\fBui\fP force, std::vector< std::vector< \fBui\fP >> & plist, std::vector< \fBldf\fP > & parameters)"

.PP
Add force type with plist\&. This function adds a new forcetype, of the given type and with the given parameters, to \fCnetwork\&.forcelibrary[]\fP and returns its index\&.
.PP
Definition at line 522 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
523 {
527     forcetype temp(force,plist,parameters);
528     network\&.forcelibrary\&.push_back(temp);
529     return network\&.forcelibrary\&.size()-1;
530 }
.fi
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::add_hook (\fBui\fP nohook, std::vector< \fBldf\fP > & parameters)"

.PP
Add a hook\&. This function adds a new hook, of the given type and with the given parameters, to \fChooks\&.hookers[]\fP and returns its index\&.
.PP
Definition at line 6 of file hooks\&.md\&.libmd\&.cc\&.
.PP
.nf
7 {
11     hooktype temp(hook,parameters);
12     hooks\&.hookers\&.push_back(temp);
13     return hooks\&.hookers\&.size()-1;
14 }
.fi
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::add_interaction (\fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > & parameters)"

.PP
Add type interaction rule\&. This function adds a new interaction, of the given type and with the given parameters, to \fCnetwork\&.library[]\fP and returns its index\&.
.PP
Definition at line 33 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
34 {
38     interactiontype itype(potential,parameters,rco,v(potential,rco,parameters));
39     if(network\&.free_library_slots\&.empty())
40     {
41         network\&.library\&.push_back(itype);
42         return network\&.library\&.size()-1;
43     }
44     else
45     {
46         ui retval=*network\&.free_library_slots\&.begin();
47         network\&.free_library_slots\&.erase(network\&.free_library_slots\&.begin());
48         network\&.library[retval]=itype;
49         return retval;
50     }
51 }
.fi
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::add_interaction (\fBui\fP potential, std::vector< \fBldf\fP > & parameters)"

.PP
Add type interaction rule\&. This function adds a new interaction, of the given type and with the given parameters, to \fCnetwork\&.library[]\fP and returns its index\&.
.PP
Definition at line 25 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
26 {
30     return add_interaction(potential,network\&.rco,parameters);
31 }
.fi
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::add_particle (\fBldf\fP mass = \fC1\&.0\fP, \fBui\fP ptype = \fC0\fP, bool fixed = \fCfalse\fP)"

.PP
Add a particle to the system\&. This function adds a particle to the system and returns its index\&. Optionally, provide its mass (default: 1\&.0), type (default: 0) and/or whether it is fixed (default: false)\&. The position and velocity of the new particle are not set\&.
.PP
Definition at line 6 of file particles\&.md\&.libmd\&.cc\&.
.PP
.nf
7 {
13     avars\&.export_force_calc=true;
14     N++;
15     particles\&.push_back(particle<dim>(mass,ptype,fixed));
16     network\&.spid\&.push_back(UI_MAX);
17     network\&.skins\&.resize(N);
18     network\&.forces\&.resize(N);
19     for(auto lib: network\&.forcelibrary) lib\&.particles\&.resize(N);
20     avars\&.reindex=true;
21     return N-1;
22 }
.fi
.PP
References UI_MAX\&.
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::add_particle (\fBldf\fP x[dim], \fBldf\fP dx[dim], \fBldf\fP mass = \fC1\&.0\fP, \fBui\fP ptype = \fC0\fP, bool fixed = \fCfalse\fP)"

.PP
Add a particle to the system at certain position with certain velocity\&. This function adds a particle to the system at position \fCx[]\fP with velocity \fCdx[]\fP and returns its index\&. Optionally, provide its mass (default: 1\&.0), type (default: 0) and/or whether it is fixed (default: false)\&.
.PP
Definition at line 40 of file particles\&.md\&.libmd\&.cc\&.
.PP
.nf
41 {
46     ldf tempx[dim],tempdx[dim];
47     memcpy(tempx,x,dim*sizeof(ldf));
48     memcpy(tempdx,dx,dim*sizeof(ldf));
49     ui i=add_particle(mass,ptype,fixed);
50     DEBUG_2("created particle #" F_UI " with given position and velocity",i);
51     memcpy(particles[i]\&.x,tempx,dim*sizeof(ldf));
52     memcpy(particles[i]\&.dx,tempdx,dim*sizeof(ldf));
53     return i;
54 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::add_particle (\fBldf\fP x[dim], \fBldf\fP dx[dim], \fBuc\fP bcond[dim], \fBldf\fP mass = \fC1\&.0\fP, \fBui\fP ptype = \fC0\fP, bool fixed = \fCfalse\fP, bool bconded = \fCtrue\fP)"

.PP
Add a particle to the system at certain position with certain velocity with certain bconds\&. This function adds a particle to the system at position \fCx[]\fP with velocity \fCdx[]\fP and returns its index\&. Optionally, provide its mass (default: 1\&.0), type (default: 0) and/or whether it is fixed (default: false)\&.
.PP
Definition at line 56 of file particles\&.md\&.libmd\&.cc\&.
.PP
.nf
57 {
62     ldf tempx[dim],tempdx[dim];
63     uc tempbcond[dim];
64     memcpy(tempx,x,dim*sizeof(ldf));
65     memcpy(tempdx,dx,dim*sizeof(ldf));
66     memcpy(tempbcond,bcond,dim*sizeof(uc));
67     ui i=add_particle(mass,ptype,fixed);
68     particles[i]\&.usepbcond=bconded;
69     DEBUG_2("created particle #" F_UI " with given position, velocity and bconds",i);
70     memcpy(particles[i]\&.x,tempx,dim*sizeof(ldf));
71     memcpy(particles[i]\&.dx,tempdx,dim*sizeof(ldf));
72     memcpy(particles[i]\&.bcond,tempbcond,dim*sizeof(uc));
73     return i;
74 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::add_particle (\fBldf\fP x[dim], \fBldf\fP mass = \fC1\&.0\fP, \fBui\fP ptype = \fC0\fP, bool fixed = \fCfalse\fP)"

.PP
Add a particle to the system at certain position\&. This function adds a particle to the system at position \fCx[]\fP and returns its index\&. Optionally, provide its mass (default: 1\&.0), type (default: 0) and/or whether it is fixed (default: false)\&. The velocity of the new particle is not set\&.
.PP
Definition at line 24 of file particles\&.md\&.libmd\&.cc\&.
.PP
.nf
25 {
31     ldf tempx[dim];
32     memcpy(tempx,x,dim*sizeof(ldf));
33     ui i=add_particle(mass,ptype,fixed);
34     DEBUG_2("created particle #" F_UI " with given position",i);
35     memcpy(particles[i]\&.x,tempx,dim*sizeof(ldf));
36     memset(particles[i]\&.dx,0,dim*sizeof(ldf));
37     return i;
38 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::add_sp (\fBui\fP sptype)"

.PP
Add a superparticle\&. This function adds a superparticle of type \fCsptype\fP to \fCnetwork\&.superparticles[]\fP and returns its index
.PP
Definition at line 6 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
7 {
11     ui spi = network\&.superparticles\&.size();
12     network\&.superparticles\&.push_back(superparticle());
13     network\&.superparticles[spi]\&.sptype = sptype;
14     DEBUG_2("added superparticle #" F_UI " with type " F_UI "",spi,sptype);
15     return spi;
16 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::add_sp_bond (\fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"

.PP
Add a superparticle bond\&. This function creates a new superparticle type and assigns it to the superparticle that \fCp1\fP and \fCp2\fP belong to\&. It then adds an interaction between the two particles, using element \fCinteraction\fP from \fCnetwork\&.library[]\fP\&. If the two particles are not in the same superparticle, or have an interaction already, it does nothing and returns false\&.
.PP
Definition at line 261 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
262 {
268     ui spi = network\&.spid[p1];
269     if (spi == UI_MAX || spi != network\&.spid[p2])
270         return false;
271     ui spt = network\&.superparticles[spi]\&.sptype;
272     std::pair<ui,ui> id = network\&.hash(network\&.superparticles[spi]\&.particles[p1], network\&.superparticles[spi]\&.particles[p2]);
273     if (network\&.sptypes[spt]\&.splookup\&.count(id))
274         return false;
275     network\&.sptypes[clone_sptype(spi)]\&.splookup[id] = interaction;
276     update_skins(p1,p2);
277     return true;
278 }
.fi
.PP
References UI_MAX\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::add_sp_bond (\fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > & parameters)"

.PP
Add a superparticle bond\&. This function creates a new superparticle type and assigns it to the superparticle that \fCp1\fP and \fCp2\fP belong to\&. It then adds an interaction between the two particles, using a new interaction of the given type and with the given parameters\&. If the two particles are not in the same superparticle, or have an interaction already, it does nothing and returns false\&.
.PP
Definition at line 312 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
313 {
319     ui spi = network\&.spid[p1];
320     if (spi == UI_MAX || spi != network\&.spid[p2])
321         return false;
322     ui spt = network\&.superparticles[spi]\&.sptype;
323     std::pair<ui,ui> id = network\&.hash(network\&.superparticles[spi]\&.particles[p1], network\&.superparticles[spi]\&.particles[p2]);
324     if (network\&.sptypes[spt]\&.splookup\&.count(id))
325         return false;
326     network\&.sptypes[clone_sptype(spi)]\&.splookup[id] = add_interaction(potential, parameters);
327     update_skins(p1,p2);
328     return true;
329 }
.fi
.PP
References UI_MAX\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::add_sp_interaction (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"

.PP
Add superparticle interaction rule\&. This function adds an interaction between particle numbers \fCp1\fP and \fCp2\fP of superparticles of type \fCspt\fP, using element \fCinteraction\fP from \fCnetwork\&.library[]\fP\&. It returns whether the given superparticletype and interaction exist and the particle numbers do not already have an interaction\&. If the two particle numbers already have an interaction, it is not modified\&.
.PP
Definition at line 300 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
301 {
308     std::pair<ui,ui> id=network\&.hash(p1,p2);
309     if(spt>=network\&.sptypes\&.size())
310     {
311         WARNING("superparticletype %d does not exist", spt);
312         return false;
313     }
314     else if(network\&.sptypes[spt]\&.splookup\&.count(id))
315         return false;
316     else if(interaction>=network\&.library\&.size())
317     {
318         WARNING("interaction %d does not exist", interaction);
319         return false;
320     }
321     else if(network\&.free_library_slots\&.count(interaction))
322     {
323         WARNING("interaction %d was previously removed", interaction);
324         return false;
325     }
326     else
327     {
328         network\&.sptypes[spt]\&.splookup[id]=interaction;
329         avars\&.reindex=true;
330         return true;
331     }
332 }
.fi
.PP
References WARNING\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::add_sp_interaction (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > & parameters)"

.PP
Add superparticle interaction rule\&. This function adds an interaction between particle numbers \fCp1\fP and \fCp2\fP of superparticles of type \fCspt\fP, using a new interaction of the given type and with the given parameters\&. It returns whether the given superparticletype exists and the particle numbers do not already have an interaction\&. If the two particle numbers already have an interaction, it is not modified and the interaction is not added to \fCnetwork\&.library[]\fP\&.
.PP
Definition at line 398 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
399 {
407     std::pair<ui,ui> id=network\&.hash(p1,p2);
408     if(spt>=network\&.sptypes\&.size())
409     {
410         WARNING("superparticletype %d does not exist", spt);
411         return false;
412     }
413     else if(network\&.sptypes[spt]\&.splookup\&.count(id))
414         return false;
415     else
416     {
417         network\&.sptypes[spt]\&.splookup[id] = add_interaction(potential,rco,parameters);
418         avars\&.reindex=true;
419         return true;
420     }
421 }
.fi
.PP
References WARNING\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::add_sp_interaction (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > & parameters)"

.PP
Add superparticle interaction rule\&. This function adds an interaction between particle numbers \fCp1\fP and \fCp2\fP of superparticles of type \fCspt\fP, using a new interaction of the given type and with the given parameters\&. It returns whether the given superparticletype exists and the particle numbers do not already have an interaction\&. If the two particle numbers already have an interaction, it is not modified and the interaction is not added to \fCnetwork\&.library[]\fP\&.
.PP
Definition at line 386 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
387 {
395     return add_sp_interaction(spt,p1,p2,potential,network\&.rco,parameters);
396 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::add_spring (\fBui\fP p1, \fBui\fP p2, \fBldf\fP springconstant, \fBldf\fP l0)"

.PP
Add a harmonic bond to the system\&. Create a hookean spring [potential type \fBHOOKEAN()\fP] between \fCp1\fP and \fCp2\fP, with spring constant and rest length prescribed by the third and fourth arguments respectively\&.
.PP
Definition at line 248 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
249 {
254     /* add a spring between two points with specified springconstant and equilibrium length */
255     std::vector<ldf> params = {springconstant, l0};
256     add_bond(p1,p2,POT::HOOKEAN,params);
257 }
.fi
.PP
References POT::HOOKEAN\&.
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::add_sptype"

.PP
Add superparticletype\&. This function adds an empty superparticletype to \fCnetwork\&.sptypes[]\fP and returns its index\&.
.PP
Definition at line 268 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
269 {
273     network\&.sptypes\&.push_back(superparticletype());
274     return network\&.sptypes\&.size()-1;
275 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::add_typeinteraction (\fBui\fP type1, \fBui\fP type2, \fBui\fP interaction)"

.PP
Add type interaction rule\&. This function adds a type interaction between the given types, using element \fCinteraction\fP from \fCnetwork\&.library[]\fP\&. It returns whether the given interaction exists and the two types do not already have an interaction\&. If the two types already have an interaction, it is not modified\&.
.PP
Definition at line 116 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
117 {
123     std::pair<ui,ui> id=network\&.hash(type1,type2);
124     if(network\&.lookup\&.count(id))
125         return false;
126     else if(interaction>=network\&.library\&.size())
127     {
128         WARNING("interaction %d does not exist", interaction);
129         return false;
130     }
131     else if(network\&.free_library_slots\&.count(interaction))
132     {
133         WARNING("interaction %d was previously removed", interaction);
134         return false;
135     }
136     else
137     {
138         network\&.lookup[id]=interaction;
139         avars\&.reindex=true;
140         return true;
141     }
142 }
.fi
.PP
References WARNING\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::add_typeinteraction (\fBui\fP type1, \fBui\fP type2, \fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > & parameters)"

.PP
Add type interaction rule\&. This function adds a type interaction between the given types, using a new interaction of the given type and with the given parameters\&. It returns whether the two types do not already have an interaction\&. If the two types already have an interaction, it is not modified and the interaction is not added to \fCnetwork\&.library[]\fP\&.
.PP
Definition at line 192 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
193 {
199     std::pair<ui,ui> id=network\&.hash(type1,type2);
200     if(!network\&.lookup\&.count(id))
201     {
202         network\&.lookup[id]=add_interaction(potential,rco,parameters);
203         avars\&.reindex=true;
204         return true;
205     }
206     else return false;
207 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::add_typeinteraction (\fBui\fP type1, \fBui\fP type2, \fBui\fP potential, std::vector< \fBldf\fP > & parameters)"

.PP
Add type interaction rule\&. This function adds a type interaction between the given types, using a new interaction of the given type and with the given parameters\&. It returns whether the two types do not already have an interaction\&. If the two types already have an interaction, it is not modified and the interaction is not added to \fCnetwork\&.library[]\fP\&.
.PP
Definition at line 182 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
183 {
189     return add_typeinteraction(type1,type2,potential,network\&.rco,parameters);
190 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::all_interactions (std::vector< std::pair< \fBui\fP, \fBui\fP >> & table)"

.PP
Dump all interaction into a table\&. This function puts a list of all interaction neighbors in \fCtable\fP, as pairs of particles\&.
.PP
Definition at line 16 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
17 {
21     table\&.clear();
22     for(ui i=0;i<N;i++) for(auto sij: network\&.skins[i]) if(i>sij\&.neighbor and distsq(i,sij\&.neighbor)<std::pow(get_rco(sij\&.interaction),2)) table\&.push_back(std::pair<ui,ui>(i,sij\&.neighbor));
23 }
.fi
.PP
References pow()\&.
.SS "template<ui dim> void \fBmd\fP< dim >::assign_all_forcetype (\fBui\fP ftype)"

.PP
Assign force type to all particles\&. This function assigns the forcetype \fCnetwork\&.forcelibrary[ftype]\fP to all particles\&.
.PP
Definition at line 602 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
603 {
607     for(ui i=0;i<N;i++) assign_forcetype(i,ftype);
608 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::assign_forcetype (\fBui\fP i, \fBui\fP ftype)"

.PP
Assign force type to particle\&. This function assigns a forcetype to particle \fCi\fP, using element \fCftype\fP from \fCnetwork\&.forcelibrary[]\fP\&. It returns whether the given forcetype was not already assigned to the given particle\&.
.PP
Definition at line 591 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
592 {
597     for(ui j=network\&.forces[i]\&.size()-1;j<UI_MAX;j--) if(network\&.forces[i][j]==ftype) return false;
598     network\&.forces[i]\&.push_back(ftype);
599     return true;
600 }
.fi
.PP
References UI_MAX\&.
.SS "template<ui dim> void \fBmd\fP< dim >::assign_unique_types (\fBui\fP p1, \fBui\fP p2)"

.PP
Assign unique types to particles, modify lookup\&. Assign unique particle types to \fCp1\fP and \fCp2\fP, that are not shared by any other particles\&. Preserves all pairwise interactions that existed between \fCp1\fP or \fCp2\fP and any other particles\&.
.PP
Definition at line 200 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
201 {
209 
210     // assign unique types to points
211     ui P[2], old_type[2], new_type[2];
212     P[0] = p1;
213     P[1] = p2;
214     ui maxtype = network\&.lookup\&.empty() ? 0 : network\&.lookup\&.rbegin()->first\&.first, i, j, q;
215 
216     for (j = 0; j < 2; j++)
217         new_type[j] = old_type[j] = particles[P[j]]\&.type;
218     for (i = 0; i < N; i++)
219         if (maxtype < particles[i]\&.type)
220             maxtype = particles[i]\&.type;
221 
222     for (j = 0; j < 2; j++)
223     {
224         for (i = 0; i < N && (i == P[j] || particles[i]\&.type != old_type[j]); i++); // Check if there is at least one other particle with same type as p1
225         if (i < N) // P[j] does not have a unique type; reassign\&.
226             set_type(P[j], new_type[j] = ++maxtype); // use one greater than largest used particle type
227         if (old_type[0] == old_type[1])
228         {   set_type(P[1], new_type[1] = new_type[0]);
229             break;
230         }
231     }
232 
233     for (j = 0; j < 2; j++)
234         if (new_type[j] != old_type[j])
235         {   // clone previously defined interactions
236             std::map<std::pair<ui,ui>,ui>::iterator it = (old_type[j]==0 ? network\&.lookup\&.begin() : network\&.lookup\&.upper_bound(std::pair<ui,ui>(old_type[j]-1, UI_MAX)));
237             for (; it != network\&.lookup\&.end() && it->first\&.first == old_type[j]; it++)
238                 if ((q = it->first\&.second) != new_type[1-j])
239                     mad_typeinteraction(new_type[j], q, it->second);
240             for (; it != network\&.lookup\&.end(); it++)
241                 if (it->first\&.second == old_type[j] && (q = it->first\&.first) != new_type[1-j])
242                     mad_typeinteraction(new_type[j], q, it->second);
243             if (old_type[0] == old_type[1])
244                 break;
245         }
246 }
.fi
.PP
References UI_MAX\&.
.SS "template<ui dim> void \fBmd\fP< dim >::bruteforce"

.PP
Bruteforce indexing algorithm\&. This brute force indexing algorithm simply checks every pair of particles\&.
.br
 This function is to be preferred over \fBmd<dim>::cell()\fP and \fBmd<dim>::kdtree()\fP if all (or most) particles are within \fCnetwork\&.ssz\fP of each other\&.
.PP
Definition at line 369 of file index\&.md\&.libmd\&.cc\&.
.PP
.nf
370 {
376     DEBUG_2("exec is here");
377     for(ui i=0;i<N;i++) network\&.skins[i]\&.clear();
378     ldf sszsq=std::pow(network\&.ssz,2);
379     for(ui i=0;i<N;i++) for(ui j=i+1;j<N;j++) skinner(i, j, sszsq);
380 }
.fi
.PP
References DEBUG_2, and pow()\&.
.SS "template<ui dim> void \fBmd\fP< dim >::calc_forces\fC [virtual]\fP"

.PP
Calculate the forces between interacting particles\&. This function clears and then calculates all the forces in the system by indexing \fBmd<dim>::index\fP if nessecary and then looping over md<dim>::thread_calc_forces\&.
.PP
Reimplemented in \fBmpmd< dim >\fP\&.
.PP
Definition at line 48 of file forces\&.md\&.libmd\&.cc\&.
.PP
.nf
49 {
53     if(network\&.update and (avars\&.reindex or test_index()))
54     {
55         DEBUG_2("regenerating skinlist");
56         index();
57     }
58     DEBUG_2("exec is here");
59     avars\&.export_force_calc=false;
60     for(ui i=0;i<N;i++) thread_clear_forces(i);
61     recalc_forces();
62 }
.fi
.PP
References DEBUG_2\&.
.SS "template<ui dim> void \fBmd\fP< dim >::cell"

.PP
Cell indexing algorithm\&. This indexing algorithm uses the cell method\&.
.br
 The system is divided into cells of equal size, which are at least \fCnetwork\&.ssz\fP in size in each dimension\&. The particles are put in their corresponding cells\&. Two particles that are in cells that do not share at least a corner will be more than \fCnetwork\&.ssz\fP apart, therefore such pairs of cells need not be checked\&.
.br

.PP
Definition at line 265 of file index\&.md\&.libmd\&.cc\&.
.PP
.nf
266 {   
267     DEBUG_2("exec is here");
274     if (network\&.ssz <= 0)
275     {   ERROR("skinsize is not positive (network\&.ssz = " F_LDF ")", network\&.ssz);
276         return;
277     }
278     ui c, d, i, k, cellId;
279     ldf x;
280     std::list<ui>::iterator a, b;
281     ldf nc = 1;
282     if (simbox\&.useLshear)
283     {   ldf R;
284         for (d = 0; d < dim; d++)
285         {   R = std::pow(dotprod<dim>(simbox\&.LshearInv[d], simbox\&.LshearInv[d]), -\&.5);
286             nc *= indexdata\&.celldata\&.Q[d] = (R < network\&.ssz ? 1 : R/network\&.ssz);
287         }
288     }
289     else
290         for (d = 0; d < dim; d++)
291             nc *= indexdata\&.celldata\&.Q[d] = (simbox\&.L[d] < network\&.ssz ? 1 : simbox\&.L[d]/network\&.ssz);
292     // If number of cells is very large (ssz very small): reduce until number of cells is in the order of N
293     for (; nc > N; nc /= 2)
294     {
295         k = 0;
296         for (d = 1; d < dim; d++)
297             if (indexdata\&.celldata\&.Q[k] < indexdata\&.celldata\&.Q[d])
298                 k = d;
299         indexdata\&.celldata\&.Q[k] = (indexdata\&.celldata\&.Q[k]+1)/2;
300     }
301     for (d = 0; d < dim; d++)
302         DEBUG_3("indexdata\&.celldata\&.Q[" F_UI "] = " F_UI " (from " F_LDF " / " F_LDF " originally)", d, indexdata\&.celldata\&.Q[d], simbox\&.L[d], network\&.ssz);
303     // Compute and check cell sizes
304     for (d = 0; d < dim; d++)
305         indexdata\&.celldata\&.CellSize[d] = simbox\&.L[d]/indexdata\&.celldata\&.Q[d];
306 
307     // Compute nCells and totNeighbors
308     indexdata\&.celldata\&.nCells = 1;
309     indexdata\&.celldata\&.totNeighbors = 0;
310     for (d = 0; d < dim; d++)
311         if (indexdata\&.celldata\&.Q[d] > 1) // Ignore dimensions with only one cell
312         {   indexdata\&.celldata\&.nCells *= indexdata\&.celldata\&.Q[d];
313             indexdata\&.celldata\&.totNeighbors = 3*indexdata\&.celldata\&.totNeighbors+1;
314         }
315 
316     // Declare dynamic arrays
317     if (indexdata\&.celldata\&.IndexDelta == nullptr || sizeof(indexdata\&.celldata\&.Cells) != indexdata\&.celldata\&.nCells*sizeof(ui)
318         || sizeof(indexdata\&.celldata\&.IndexDelta) != indexdata\&.celldata\&.totNeighbors*dim*sizeof(int)
319         || sizeof(indexdata\&.celldata\&.OutsideBox) != N)
320     {   delete[] indexdata\&.celldata\&.Cells;
321         delete[] indexdata\&.celldata\&.IndexDelta;
322         delete[] indexdata\&.celldata\&.OutsideBox;
323         indexdata\&.celldata\&.Cells = new std::vector<ui>[indexdata\&.celldata\&.nCells];
324         indexdata\&.celldata\&.IndexDelta = new int[indexdata\&.celldata\&.totNeighbors][dim]; // Relative position of neighboring cell
325         indexdata\&.celldata\&.OutsideBox = new bool[N];
326     }
327     // Determine all (potential) neighbors
328     // Start with {0,0,\&.\&.\&.,0,+1}
329     if (indexdata\&.celldata\&.totNeighbors > 0)
330     {   memset(indexdata\&.celldata\&.IndexDelta[0], 0, dim*sizeof(ui));
331         for (d = dim-1; indexdata\&.celldata\&.Q[d] == 1; d--);
332         indexdata\&.celldata\&.IndexDelta[0][d] = 1;
333         for (i = 1; i < indexdata\&.celldata\&.totNeighbors; i++)
334         {   memcpy(indexdata\&.celldata\&.IndexDelta[i], indexdata\&.celldata\&.IndexDelta[i-1], dim*sizeof(ui));
335             // Set all trailing +1's to -1
336             for (d = dim-1; d < dim && (indexdata\&.celldata\&.Q[d] == 1 || indexdata\&.celldata\&.IndexDelta[i][d] == 1); d--)
337                 if (indexdata\&.celldata\&.Q[d] > 1)
338                     indexdata\&.celldata\&.IndexDelta[i][d] = -1;
339             // Increase last not-plus-one by one
340             if (d < dim)
341                 indexdata\&.celldata\&.IndexDelta[i][d]++;
342         }
343     }
344 
345     // Put the particles in their cells
346     for (c = 0; c < indexdata\&.celldata\&.nCells; c++)
347         indexdata\&.celldata\&.Cells[c]\&.clear();
348     for (i = 0; i < N; i++)
349     {   cellId = 0;
350         indexdata\&.celldata\&.OutsideBox[i] = false;
351         for (d = 0; d < dim; d++)
352         {   x = (simbox\&.useLshear ? dotprod<dim>(simbox\&.LshearInv[d], particles[i]\&.x) : particles[i]\&.x[d] / simbox\&.L[d]);
353             if (std::abs(x) > \&.5+1e-9)
354             {   indexdata\&.celldata\&.OutsideBox[i] = true;
355                 cellId = indexdata\&.celldata\&.Q[d] * cellId + (x < 0 ? 0 : indexdata\&.celldata\&.Q[d]-1);
356             }
357             else
358                 cellId = indexdata\&.celldata\&.Q[d] * cellId + (x < -\&.5+3e-9 ? 0 : (ui)(indexdata\&.celldata\&.Q[d]*(x+\&.5-2e-9)));
359         }
360         indexdata\&.celldata\&.Cells[cellId]\&.push_back(i);
361     }
362 
363     for (i = 0; i < N; i++)
364         network\&.skins[i]\&.clear();
365 
366     for(ui c=0;c<indexdata\&.celldata\&.nCells;c++) thread_cell(c);
367 }
.fi
.PP
References abs(), DEBUG_2, DEBUG_3, ERROR, F_LDF, F_UI, and pow()\&.
.SS "template<ui dim> void \fBmd\fP< dim >::clear"

.PP
Clear all particles and interactions\&. Remove all particles from the \fBmd\fP structure, and clear all data types storing interactions and superparticle data\&. Leaves the system box and the boundary conditions unchanged\&.
.PP
Definition at line 50 of file md\&.libmd\&.cc\&.
.PP
.nf
51 {
57     N=0;
58     particles\&.clear();
59     network\&.skins\&.clear();
60     network\&.library\&.clear();
61     network\&.lookup\&.clear();
62     network\&.spid\&.clear();
63     network\&.superparticles\&.clear();
64     network\&.sptypes\&.clear();
65     network\&.forcelibrary\&.clear();
66     network\&.forces\&.clear();
67     network\&.free_library_slots\&.clear();
68 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::clear_all_assigned_forcetype"

.PP
Clear all assigned forces\&. This function removes all forcetypes from all particles\&.
.PP
Definition at line 633 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
634 {
638     for(ui i=0;i<N;i++) network\&.forces[i]\&.clear();
639 }
.fi
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::clone_particle (\fBui\fP i, \fBldf\fP x[dim])"

.PP
Clone a particle and translate\&. This function creates a new particle that is a copy of particle \fCi\fP\&. The position of the new particle is translated by the vector \fCx[]\fP with respect to the original one\&. It returns the index of the new particle\&.
.PP
Definition at line 156 of file particles\&.md\&.libmd\&.cc\&.
.PP
.nf
157 {
163     DEBUG_2("cloning particle #" F_UI "",i);
164     ui retval=add_particle();
165     particles[retval]=particles[i];
166     translate_particle(retval,x);
167     network\&.forces[retval]=network\&.forces[i];
168     for(auto j:network\&.forces[i]) if(!network\&.forcelibrary[j]\&.particles\&.empty()) network\&.forcelibrary[j]\&.particles[retval]=network\&.forcelibrary[j]\&.particles[i];
169     for(auto f:network\&.forcelibrary) for(auto u:f\&.particles) for(auto v:u) if(v==i) u\&.push_back(retval);
170     return retval;
171 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::clone_sp (\fBui\fP spi, \fBldf\fP x[dim])"

.PP
Clone a superparticle and translate\&. This function creates a new superparticle that is a copy of the superparticle with index \fCspi\fP, with new particles\&. The position of all the new particles are translated by the vector \fCx[]\fP with respect to the original ones\&. It returns the index of the new superparticle in \fCnetwork\&.superparticles[]\fP\&.
.PP
Definition at line 198 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
199 {
205     DEBUG_2("cloning superparticle #" F_UI "",spi);
206     ui retval=add_sp(network\&.superparticles[spi]\&.sptype);
207     network\&.superparticles[retval]\&.backdoor=network\&.superparticles[spi]\&.backdoor;
208     ui K=network\&.superparticles[spi]\&.backdoor\&.size(),i;
209     for(ui k=0;k<K;k++)
210     {
211         if((i=network\&.superparticles[spi]\&.backdoor[k])<UI_MAX)
212         {
213             ui p=clone_particle(i,x);
214             network\&.spid[p]=retval;
215             network\&.superparticles[retval]\&.particles[p]=k;
216             network\&.superparticles[retval]\&.backdoor[k]=p;
217         }
218     }
219     for(auto f:network\&.forcelibrary) for(auto u:f\&.particles) for(auto &v:u) if(network\&.spid[v]==spi) v=network\&.superparticles[retval]\&.backdoor[network\&.superparticles[spi]\&.particles[v]];
220     return retval;
221 }
.fi
.PP
References DEBUG_2, F_UI, and UI_MAX\&.
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::clone_sptype (\fBui\fP sp)"

.PP
Make a new sptype for superparticle sp if it is not unique to sp\&. This function creates a new superparticle type that is exactly the same as that of superparticle \fCspi\fP, assigns it to the superparticle and returns its index in \fCnetwork\&.sptypes[]\fP\&. If superparticle \fCspi\fP is the only superparticle of its type, this fuction does nothing and returns the index of its type in \fCnetwork\&.sptypes[]\fP\&.
.PP
Definition at line 382 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
383 {
390     ui i, spt = network\&.superparticles[spi]\&.sptype;
391     // Check for uniqueness
392     for (i = network\&.superparticles\&.size()-1; i < UI_MAX && (i == spi || network\&.superparticles[i]\&.sptype != spt); i--);
393     if (i < UI_MAX)
394     {   network\&.sptypes\&.push_back(network\&.sptypes[spt]);
395         return network\&.superparticles[spi]\&.sptype = network\&.sptypes\&.size()-1;
396     }
397     else
398         return spt;
399 }
.fi
.PP
References UI_MAX\&.
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::dap (\fBui\fP d, \fBldf\fP ad)"

.PP
Manipulate particle distances with respect to periodic boundary conditions\&. Given a displacement \fCad\fP and corresponding spatial dimension \fCd\fP, calculates the displacement modulo the periodic box size in that dimension\&.
.PP
Under periodic boundary conditions, distances are required to lie in the range \fC(-simbox\&.L[d]/2,simbox\&.L[d]/2)\fP\&. If the displacement \fCdap\fP is outside this range, multiples of \fCsimbox\&.L[d]\fP are added or subtracted until the displacement is within these bounds, and the result is returned\&.
.PP
Definition at line 6 of file distances\&.md\&.libmd\&.cc\&.
.PP
.nf
7 {
17     ldf da;
18     switch(simbox\&.bcond[d])
19     {
20         case BCOND::PERIODIC: da=std::abs(ad)<0\&.5*simbox\&.L[d]?ad:ad-std::abs(ad+0\&.5*simbox\&.L[d])+std::abs(ad-0\&.5*simbox\&.L[d]); break;
21         default: da=ad; break;
22     }
23     return da;
24 }
.fi
.PP
References abs(), and BCOND::PERIODIC\&.
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::dd (\fBui\fP d, \fBldf\fP x1[dim], \fBldf\fP x2[dim])"

.PP
Calculate difference in particle positions in certain dimension i by particle index\&. This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
This version accepts as inputs the coordinates of two points in arrays \fCx1[dim]\fP and \fCx2[dim]\fP and returns the (periodic) distance between them along spatial dimension \fCd\fP\&.
.PP
Definition at line 91 of file distances\&.md\&.libmd\&.cc\&.
.PP
.nf
92 {
99     ldf ddd=0;
100     if (simbox\&.useLshear) for(ui mu=0;mu<dim;mu++) // use box matrix to calculate distances
101     {
102        ldf s=0;
103        for(ui nu=0;nu<dim;nu++) s+=simbox\&.LshearInv[mu][nu]*(x2[nu]-x1[nu]);
104        if (simbox\&.bcond[mu]==BCOND::PERIODIC or simbox\&.bcond[mu]==BCOND::BOXSHEAR) s=std::abs(s)<0\&.5?s:s-std::abs(s+0\&.5)+std::abs(s-0\&.5);
105        ddd += simbox\&.Lshear[d][mu]*s;
106     }
107     else
108     {
109         ldf ad=x2[d]-x1[d];
110         ddd=dap(d,ad);
111     }
112     return ddd;
113 }
.fi
.PP
References abs(), BCOND::BOXSHEAR, and BCOND::PERIODIC\&.
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::dd (\fBui\fP d, \fBldf\fP x1[dim], \fBui\fP p2)"

.PP
Calculate difference in particle positions in certain dimension i by particle index\&. This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
This version accepts as inputs a point coordinate array \fCx1[dim]\fP and a point index \fCp2\fP and returns the (periodic) distance between them along spatial dimension \fCd\fP\&.
.PP
Definition at line 126 of file distances\&.md\&.libmd\&.cc\&.
.PP
.nf
127 {
134     return dd(d,x1,particles[p2]\&.x);
135 }
.fi
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::dd (\fBui\fP d, \fBui\fP p1, \fBldf\fP x2[dim])"

.PP
Calculate difference in particle positions in certain dimension i by particle index\&. This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
This version accepts as inputs a point index \fCp1\fP and point coordinate array \fCx2[dim]\fP and returns the (periodic) distance between them along spatial dimension \fCd\fP\&.
.PP
Definition at line 115 of file distances\&.md\&.libmd\&.cc\&.
.PP
.nf
116 {
123     return dd(d,particles[p1]\&.x,x2);
124 }
.fi
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::dd (\fBui\fP d, \fBui\fP p1, \fBui\fP p2)"

.PP
Calculate difference in particle positions in certain dimension i by particle index\&. Returns the distance between points indexed by \fCp1\fP and \fCp2\fP along spatial dimension \fCd\fP\&. If periodic boundary conditions are used, the distance is between the closest periodic images of the two points\&.
.PP
Definition at line 79 of file distances\&.md\&.libmd\&.cc\&.
.PP
.nf
80 {
88     return dd(d,particles[p1]\&.x,particles[p2]\&.x);
89 }
.fi
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::direct_readout (\fBui\fP d, \fBui\fP i, \fBuc\fP type)"

.PP
Directly readout a position'x'/velocity'v'/forces'F'\&. This function is convenience function for \fC type\fP: 
.PD 0

.IP "\(bu" 2
\fCtype='v'\fP \fBmd<dim>::direct_readout_dx\fP \fC(d,i)\fP 
.IP "\(bu" 2
\fCtype='F'\fP \fBmd<dim>::direct_readout_dx\fP \fC(d,i)\fP 
.IP "\(bu" 2
\fCdefault\fP \fBmd<dim>::direct_readout_dx\fP \fC(d,i)\fP 
.PP

.PP
Definition at line 345 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
346 {
355     switch(type)
356     {
357         case 'v': return direct_readout_dx(d,i); break;
358         case 'F': return direct_readout_F(d,i); break;
359         default: return direct_readout_x(d,i); break;
360     }
361 }
.fi
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::direct_readout (\fBui\fP i, \fBuc\fP type)"

.PP
Directly readout a position'x'/velocity'v'/forces'F'\&. This function is convenience function for \fC type\fP: 
.PD 0

.IP "\(bu" 2
\fCtype='v'\fP \fBmd<dim>::direct_readout_dx\fP \fC(d=vvars,i)\fP 
.IP "\(bu" 2
\fCtype='F'\fP \fBmd<dim>::direct_readout_dx\fP \fC(d=vvars,i)\fP 
.IP "\(bu" 2
\fCdefault\fP \fBmd<dim>::direct_readout_dx\fP \fC(d=vvars,i)\fP 
.PP
vvars is variadic_var
.PP
Definition at line 325 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
326 {
336     ui d=vvars[6];
337     switch(type)
338     {
339         case 'v': return direct_readout_dx(d,i); break;
340         case 'F': return direct_readout_F(d,i); break;
341         default: return direct_readout_x(d,i); break;
342     }
343 }
.fi
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::direct_readout_dx (\fBui\fP d, \fBui\fP i)"

.PP
Directly readout a velocity\&. This function is a somewhat redundant function that returns \fCparticles[i]\&.dx[d]\fP\&.
.PP
Definition at line 308 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
309 {
313     return particles[i]\&.dx[d];
314 }
.fi
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::direct_readout_F (\fBui\fP d, \fBui\fP i)"

.PP
Directly readout a forces\&. This function returns \fCparticles[i]\&.F[d]\fP after it checks if a Force calculation is necessary\&.
.PP
Definition at line 316 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
317 {
321     if(avars\&.export_force_calc) calc_forces();
322     return particles[i]\&.F[d];
323 }
.fi
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::direct_readout_x (\fBui\fP d, \fBui\fP i)"

.PP
Directly readout a position\&. This function is a somewhat redundant function that returns \fCparticles[i]\&.x[d]\fP\&.
.PP
Definition at line 300 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
301 {
305     return particles[i]\&.x[d];
306 }
.fi
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::distsq (\fBldf\fP x1[dim], \fBldf\fP x2[dim])"

.PP
Calculate distances between two particles (squared) ldf \fBdistsq(ui p1,ldf x2[dim])\fP; ///< Calculate distances between two particles (squared) This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
This version accepts as inputs the coordinates of two points in arrays \fCx1[dim]\fP and \fCx2[dim]\fP and returns the squared (periodic) distance between them\&.
.PP
Definition at line 40 of file distances\&.md\&.libmd\&.cc\&.
.PP
.nf
41 {
48     ldf retval=0\&.0;
49     for(ui d=0;d<dim;d++) retval+=std::pow(dd(d,x1,x2),2);
50     return retval;
51 }
.fi
.PP
References pow()\&.
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::distsq (\fBldf\fP x1[dim], \fBui\fP p2)"

.PP
Calculate distances between two particles (squared) This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
This version accepts as inputs a point coordinate array \fCx1[dim]\fP and a point index \fCp2\fP and returns the squared (periodic) distance between them\&.
.PP
Definition at line 66 of file distances\&.md\&.libmd\&.cc\&.
.PP
.nf
67 {
74     ldf retval=0\&.0;
75     for(ui d=0;d<dim;d++) retval+=std::pow(dd(d,x1,p2),2);
76     return retval;
77 }
.fi
.PP
References pow()\&.
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::distsq (\fBui\fP p1, \fBldf\fP x2[dim])"

.PP
Calculate distances between two particles (squared) This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
This version accepts as inputs a point index \fCp1\fP and point coordinate array \fCx2[dim]\fP and returns the squared (periodic) distance between them\&.
.PP
Definition at line 53 of file distances\&.md\&.libmd\&.cc\&.
.PP
.nf
54 {
61     ldf retval=0\&.0;
62     for(ui d=0;d<dim;d++) retval+=std::pow(dd(d,p1,x2),2);
63     return retval;
64 }
.fi
.PP
References pow()\&.
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::distsq (\fBui\fP p1, \fBui\fP p2)"

.PP
Calculate distances between two particles (squared) Returns the square of the distance between points indexed by \fCp1\fP and \fCp2\fP\&. If periodic boundary conditions are used, the distance is between the closest periodic images of the two points\&.
.PP
Definition at line 26 of file distances\&.md\&.libmd\&.cc\&.
.PP
.nf
27 {
35     ldf retval=0\&.0;
36     for(ui d=0;d<dim;d++) retval+=std::pow(dd(d,p1,p2),2);
37     return retval;
38 }
.fi
.PP
References pow()\&.
.SS "template<ui dim> void \fBmd\fP< dim >::drift_particle (\fBui\fP i, \fBldf\fP dx[dim])"

.PP
Add velocity to a particle\&. This function adds the vector \fCdx[]\fP to the velocity of particle \fCi\fP\&.
.PP
Definition at line 189 of file particles\&.md\&.libmd\&.cc\&.
.PP
.nf
190 {
194     DEBUG_2("drifting particle #" F_UI "",i);
195     for(ui d=0;d<dim;d++) particles[i]\&.dx[d]+=dx[d];
196 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> void \fBmd\fP< dim >::drift_sp (\fBui\fP spi, \fBldf\fP dx[dim])"

.PP
Add velocity to a super particle (all particles the same) This function adds the vector \fCdx[]\fP to the velocities all particles belonging to the superparticle with index \fCspi\fP\&.
.PP
Definition at line 232 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
233 {
237     DEBUG_2("drifting superparticle #" F_UI "",spi);
238     for(auto it=network\&.superparticles[spi]\&.particles\&.begin();it!=network\&.superparticles[spi]\&.particles\&.end();it++) drift_particle(it->first,dx);
239 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::dv (\fBui\fP d, \fBui\fP p1, \fBui\fP p2)"

.PP
Calculate difference in particle velocities in certain dimension i by particle index\&. Returns the \fCd\fPth component of the velocity difference between the closest periodic image of two particles indexed by \fCp1\fP and \fCp2\fP\&. If the vector connecting the periodic images crosses a sheared boundary, the resulting velocity difference takes into account the shear velocity of the periodic image as well\&. The result is returned as a $d$-dimensional array of velocity components\&.
.PP
Definition at line 137 of file distances\&.md\&.libmd\&.cc\&.
.PP
.nf
138 {
147     ldf dv = particles[p2]\&.dx[d]-particles[p1]\&.dx[d];
148     if (simbox\&.useLshear)
149     {
150         // use box matrix to calculate boundary crossings, and adjust relative velocity accordingly
151         for (ui j=0;j<dim;j++)
152         {
153             ldf s=0,bcross=0;
154             for (ui k=0;k<dim;k++)
155             {
156                s+=simbox\&.LshearInv[j][k]*(particles[p2]\&.x[k]-particles[p1]\&.x[k]);
157             }
158             if (std::abs(s) > 0\&.5 and (simbox\&.bcond[j]==BCOND::PERIODIC or simbox\&.bcond[j]==BCOND::BOXSHEAR)) bcross = floor(s+\&.5);
159             dv -= simbox\&.vshear[d][j]*bcross;
160         }
161     }
162     return dv;
163 }
.fi
.PP
References abs(), BCOND::BOXSHEAR, and BCOND::PERIODIC\&.
.SS "template<ui dim> void \fBmd\fP< dim >::export_force (\fBldf\fP * F)"

.PP
Save forces from arrays\&. This function takes an arbitrary number of arrays\&. 
.br
 The array is assumed to be of length N, the number of particles\&. 
.br
 Then for each \fCi\fPth particle force every \fCd\fPth component is assigned to that array 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&. This function checks if forces need to be recalculated
.PP
Definition at line 246 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
247 {
255     ui d=vvars[5];
256     if(avars\&.export_force_calc) calc_forces();
257     for(ui i=0;i<N;i++) F[i]=particles[i]\&.F[d];
258 }
.fi
.SS "template<ui dim> template<typename\&.\&.\&. arg> void \fBmd\fP< dim >::export_force (\fBldf\fP * F, arg\&.\&.\&. argv)"

.PP
Save forces to arrays\&. This function takes an arbitrary number of arrays\&. 
.br
 The array is assumed to be of length N, the number of particles\&. 
.br
 Then for each \fCi\fPth particle force every \fCd\fPth component is assigned to that array 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&. This function checks if forces need to be recalculated
.PP
Definition at line 260 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
261 {
269     ui d=vvars[5];
270     if(avars\&.export_force_calc) calc_forces();
271     for(ui i=0;i<N;i++) F[i]=particles[i]\&.F[d];
272     export_force(argv\&.\&.\&.);
273 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::export_force (\fBui\fP i, \fBldf\fP & F)"

.PP
Save forces from arrays\&. This function takes an arbitrary number of values\&. 
.br
 Then for each \fCi\fPth particle force every \fCd\fPth component is assigned to that value 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 275 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
276 {
282     ui d=vvars[5];
283     if(avars\&.export_force_calc) calc_forces();
284     F=particles[i]\&.F[d];
285 }
.fi
.SS "template<ui dim> template<typename\&.\&.\&. arg> void \fBmd\fP< dim >::export_force (\fBui\fP i, \fBldf\fP & F, arg\&.\&.\&. argv)"

.PP
Save forces to arrays\&. This function takes an arbitrary number of values\&. 
.br
 Then for each \fCi\fPth particle force every \fCd\fPth component is assigned to that value 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 287 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
288 {
294     ui d=vvars[5];
295     if(avars\&.export_force_calc) calc_forces();
296     F=particles[i]\&.F[d];
297     export_force(i,argv\&.\&.\&.);
298 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::export_pos (\fBldf\fP * x)"

.PP
Save positions from arrays\&. This function takes an arbitrary number of arrays\&. 
.br
 The array is assumed to be of length N, the number of particles\&. 
.br
 Then for each \fCi\fPth particle position every \fCd\fPth component is assigned to that array 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 150 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
151 {
158     ui d=vvars[3];
159     for(ui i=0;i<N;i++) x[i]=particles[i]\&.x[d];
160 }
.fi
.SS "template<ui dim> template<typename\&.\&.\&. arg> void \fBmd\fP< dim >::export_pos (\fBldf\fP * x, arg\&.\&.\&. argv)"

.PP
Save positions to arrays\&. This function takes an arbitrary number of arrays\&. 
.br
 The array is assumed to be of length N, the number of particles\&. 
.br
 Then for each \fCi\fPth particle position every \fCd\fPth component is assigned to that array 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 162 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
163 {
170     ui d=vvars[3];
171     for(ui i=0;i<N;i++) x[i]=particles[i]\&.x[d];
172     export_pos(argv\&.\&.\&.);
173 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::export_pos (\fBui\fP i, \fBldf\fP & x)"

.PP
Save positions from arrays\&. This function takes an arbitrary number of values\&. 
.br
 Then for each \fCi\fPth particle position every \fCd\fPth component is assigned to that value 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 175 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
176 {
182     ui d=vvars[3];
183     x=particles[i]\&.x[d];
184 }
.fi
.SS "template<ui dim> template<typename\&.\&.\&. arg> void \fBmd\fP< dim >::export_pos (\fBui\fP i, \fBldf\fP & x, arg\&.\&.\&. argv)"

.PP
Save positions to arrays\&. This function takes an arbitrary number of values\&. 
.br
 Then for each \fCi\fPth particle position every \fCd\fPth component is assigned to that value 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 186 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
187 {
193     ui d=vvars[3];
194     x=particles[i]\&.x[d];
195     export_pos(i,argv\&.\&.\&.);
196 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::export_vel (\fBldf\fP * dx)"

.PP
Save velocity from arrays\&. This function takes an arbitrary number of arrays\&. 
.br
 The array is assumed to be of length N, the number of particles\&. 
.br
 Then for each \fCi\fPth particle velocity every \fCd\fPth component is assigned to that array 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 198 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
199 {
206     ui d=vvars[4];
207     for(ui i=0;i<N;i++) dx[i]=particles[i]\&.dx[d];
208 }
.fi
.SS "template<ui dim> template<typename\&.\&.\&. arg> void \fBmd\fP< dim >::export_vel (\fBldf\fP * dx, arg\&.\&.\&. argv)"

.PP
Save velocity to arrays\&. This function takes an arbitrary number of arrays\&. 
.br
 The array is assumed to be of length N, the number of particles\&. 
.br
 Then for each \fCi\fPth particle velocity every \fCd\fPth component is assigned to that array 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 210 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
211 {
218     ui d=vvars[4];
219     for(ui i=0;i<N;i++) dx[i]=particles[i]\&.dx[d];
220     export_vel(argv\&.\&.\&.);
221 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::export_vel (\fBui\fP i, \fBldf\fP & dx)"

.PP
Save positions from arrays\&. This function takes an arbitrary number of values\&. 
.br
 Then for each \fCi\fPth particle velocity every \fCd\fPth component is assigned to that value 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 223 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
224 {
230     ui d=vvars[4];
231     dx=particles[i]\&.dx[d];
232 }
.fi
.SS "template<ui dim> template<typename\&.\&.\&. arg> void \fBmd\fP< dim >::export_vel (\fBui\fP i, \fBldf\fP & dx, arg\&.\&.\&. argv)"

.PP
Save positions to arrays\&. This function takes an arbitrary number of values\&. 
.br
 Then for each \fCi\fPth particle velocity every \fCd\fPth component is assigned to that value 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 234 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
235 {
241     ui d=vvars[4];
242     dx=particles[i]\&.dx[d];
243     export_vel(i,argv\&.\&.\&.);
244 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::fix_particle (\fBui\fP i, bool fix)"

.PP
Fix a particle\&. This function fixes (\fCfix=true\fP) or unfixes (\fCfix=false\fP) particle \fCi\fP
.PP
Definition at line 147 of file particles\&.md\&.libmd\&.cc\&.
.PP
.nf
148 {
152     DEBUG_2("%sfixing particle #" F_UI "",fix?"":"un",i);
153     particles[i]\&.fix=fix;
154 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> void \fBmd\fP< dim >::fix_sp (\fBui\fP spi, bool fix)"

.PP
Fix a super particles\&. This function fixes (\fCfix=true\fP) or unfixes (\fCfix=false\fP) all the particles belonging to the superparticle with index \fCspi\fP\&.
.PP
Definition at line 188 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
189 {
194     DEBUG_2("%sfixing superparticle #" F_UI "",fix?"":"un",spi);
195     for(auto it=network\&.superparticles[spi]\&.particles\&.begin();it!=network\&.superparticles[spi]\&.particles\&.end();it++) particles[it->first]\&.fix=fix;
196 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> void \fBmd\fP< dim >::get_position_sp (\fBui\fP spi, \fBldf\fP x[dim])"

.PP
Get center of mass of super particle\&. This function puts the position of the center of mass of the superparticle with index \fCspi\fP in the vector \fCx[]\fP\&.
.PP
Definition at line 272 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
273 {
277     DEBUG_2("calculating center of mass of superparticle #" F_UI "",spi);
278     ldf m=0\&.0;
279     memset(x,0,dim*sizeof(ldf));
280     ui i=network\&.superparticles[spi]\&.particles\&.begin()->first;
281     for(auto it=network\&.superparticles[spi]\&.particles\&.begin();it!=network\&.superparticles[spi]\&.particles\&.end();it++)
282     {
283         for(ui d=0;d<dim;d++) x[d]+=particles[it->first]\&.m*dd(d,i,it->first);
284         m+=particles[it->first]\&.m;
285     }
286     for(ui d=0;d<dim;d++) x[d]=particles[i]\&.x[d]+x[d]/m;
287     thread_periodicity(x);
288 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::get_rco (\fBui\fP i, \fBui\fP j)"

.PP
Gets the cuttoff radius for a certain pair of particles\&. This fucntion returns the $R_{\text{cutoff}}$ for an interacing pair of particles \fCi\fP and \fCj\fP
.PP
Definition at line 120 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
121 {
125     auto it=network\&.lookup\&.find(network\&.hash(particles[i]\&.type,particles[j]\&.type));
126     if(it!=network\&.lookup\&.end()) return get_rco(it->second);
127     else return std::numeric_limits<ldf>::quiet_NaN();
128 }
.fi
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::get_rco (\fBui\fP interaction)"

.PP
Gets the cuttoff radius for a certain interaction\&. This fucntion returns the $R_{\text{cutoff}}$ for a certain interaction
.PP
Definition at line 130 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
131 {
135     return network\&.library[interaction]\&.rco;
136 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::get_velocity_sp (\fBui\fP spi, \fBldf\fP dx[dim])"

.PP
Get average velocity of a super particle\&. This function puts the velocity of the center of mass of the superparticle with index \fCspi\fP in the vector \fCdx[]\fP\&.
.PP
Definition at line 290 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
291 {
295     DEBUG_2("calculating velocity of center of mass of superparticle #" F_UI "",spi);
296     ldf m=0\&.0;
297     memset(dx,0,dim*sizeof(ldf));
298     for(ui d=0;d<dim;d++) dx[d]=0\&.0;
299     for(auto it=network\&.superparticles[spi]\&.particles\&.begin();it!=network\&.superparticles[spi]\&.particles\&.end();it++)
300     {
301         for(ui d=0;d<dim;d++) dx[d]+=particles[it->first]\&.m*particles[it->first]\&.dx[d];
302         m+=particles[it->first]\&.m;
303     }
304     for(ui d=0;d<dim;d++) dx[d]/=m;
305 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::H"

.PP
Measure Hamiltonian\&. Returns the total energy (kinetic and potential) of the system
.PP
Definition at line 45 of file energy\&.md\&.libmd\&.cc\&.
.PP
.nf
46 {
50     return T()+V();
51 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::heat_particle (\fBui\fP i, \fBldf\fP lambda)"

.PP
Multiply velocity vector of a particle with a scalar\&. This function increases the velocity of particle \fCi\fP by a factor of \fClambda\fP\&.
.PP
Definition at line 198 of file particles\&.md\&.libmd\&.cc\&.
.PP
.nf
199 {
203     DEBUG_2("heating particle #" F_UI "",i);
204     for(ui d=0;d<dim;d++) particles[i]\&.dx[d]*=lambda;
205 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> void \fBmd\fP< dim >::heat_sp (\fBui\fP spi, \fBldf\fP lambda)"

.PP
Multiply velocity vectors of a super particle with a scalar (all particles the same) This function increases the velocity of all particles belonging to the superparticle with index \fCspi\fP by a factor of \fClambda\fP\&.
.PP
Definition at line 241 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
242 {
246     DEBUG_2("heating superparticle #" F_UI "",spi);
247     for(auto it=network\&.superparticles[spi]\&.particles\&.begin();it!=network\&.superparticles[spi]\&.particles\&.end();it++) drift_particle(it->first,lambda);
248 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> void \fBmd\fP< dim >::import_force (\fBldf\fP * F)"

.PP
Load forces from arrays\&. This function takes an arbitrary number of arrays\&. 
.br
 The array is assumed to be of length N, the number of particles\&. 
.br
 Each \fCi\fPth element is then assigned to the particle the \fCd\fPth component of the particle's force
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 102 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
103 {
110     ui d=vvars[2];
111     for(ui i=0;i<N;i++) particles[i]\&.F[d]=F[i];
112 }
.fi
.SS "template<ui dim> template<typename\&.\&.\&. arg> void \fBmd\fP< dim >::import_force (\fBldf\fP * F, arg\&.\&.\&. argv)"

.PP
Load forces from arrays\&. This function takes an arbitrary number of arrays\&. 
.br
 The array is assumed to be of length N, the number of particles\&. 
.br
 Each \fCi\fPth element is then assigned to the particle the \fCd\fPth component of the particle's force
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 114 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
115 {
122     ui d=vvars[2];
123     for(ui i=0;i<N;i++) particles[i]\&.F[d]=F[i];
124     import_force(argv\&.\&.\&.);
125 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::import_force (\fBui\fP i, \fBldf\fP F)"

.PP
Load position for i from value\&. This function takes an arbitrary number of values\&. 
.br
 The values are then then assigned to the \fCd\fPth component of the \fCi\fPth particle's force 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every value\&.
.PP
Definition at line 127 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
128 {
134     ui d=vvars[2];
135     particles[i]\&.F[d]=F;
136 }
.fi
.SS "template<ui dim> template<typename\&.\&.\&. arg> void \fBmd\fP< dim >::import_force (\fBui\fP i, \fBldf\fP F, arg\&.\&.\&. argv)"

.PP
Load position for i from value\&. This function takes an arbitrary number of values\&. 
.br
 The values are then then assigned to the \fCd\fPth component of the \fCi\fPth particle's force 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every value\&.
.PP
Definition at line 138 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
139 {
145     ui d=vvars[2];
146     particles[i]\&.F[d]=F;
147     import_force(i,argv\&.\&.\&.);
148 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::import_pos (\fBldf\fP * x)"

.PP
Load positions from arrays\&. This function takes an arbitrary number of arrays\&. 
.br
 The array is assumed to be of length N, the number of particles\&. 
.br
 Each \fCi\fPth element is then assigned to the particle the \fCd\fPth component of the particle's position 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 6 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
7 {
14     ui d=vvars[0];
15     for(ui i=0;i<N;i++) particles[i]\&.x[d]=x[i];
16 }
.fi
.SS "template<ui dim> template<typename\&.\&.\&. arg> void \fBmd\fP< dim >::import_pos (\fBldf\fP * x, arg\&.\&.\&. argv)"

.PP
Load positions from arrays\&. This function takes an arbitrary number of arrays\&. 
.br
 The array is assumed to be of length N, the number of particles\&. 
.br
 Each \fCi\fPth element is then assigned to the particle the \fCd\fPth component of the particle's position 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 18 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
19 {
26     ui d=vvars[0];
27     for(ui i=0;i<N;i++) particles[i]\&.x[d]=x[i];
28     import_pos(argv\&.\&.\&.);
29 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::import_pos (\fBui\fP i, \fBldf\fP x)"

.PP
Load position for i from value\&. This function takes an arbitrary number of values\&. 
.br
 The values are then then assigned to the \fCd\fPth component of the \fCi\fPth particle's position 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every value\&.
.PP
Definition at line 31 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
32 {
38     ui d=vvars[0];
39     particles[i]\&.x[d]=x;
40 }
.fi
.SS "template<ui dim> template<typename\&.\&.\&. arg> void \fBmd\fP< dim >::import_pos (\fBui\fP i, \fBldf\fP x, arg\&.\&.\&. argv)"

.PP
Load position for i from value\&. This function takes an arbitrary number of values\&. 
.br
 The values are then then assigned to the \fCd\fPth component of the \fCi\fPth particle's position 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every value\&.
.PP
Definition at line 42 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
43 {
49     ui d=vvars[0];
50     particles[i]\&.x[d]=x;
51     import_pos(i,argv\&.\&.\&.);
52 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::import_vel (\fBldf\fP * dx)"

.PP
Load velocity from arrays\&. This function takes an arbitrary number of arrays\&. 
.br
 The array is assumed to be of length N, the number of particles\&. 
.br
 Each \fCi\fPth element is then assigned to the particle the \fCd\fPth component of the particle's velocity 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 54 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
55 {
62     ui d=vvars[1];
63     for(ui i=0;i<N;i++) particles[i]\&.dx[d]=dx[i];
64 }
.fi
.SS "template<ui dim> template<typename\&.\&.\&. arg> void \fBmd\fP< dim >::import_vel (\fBldf\fP * dx, arg\&.\&.\&. argv)"

.PP
Load velocity from arrays\&. This function takes an arbitrary number of arrays\&. 
.br
 The array is assumed to be of length N, the number of particles\&. 
.br
 Each \fCi\fPth element is then assigned to the particle the \fCd\fPth component of the particle's velocity 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every array\&.
.PP
Definition at line 66 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
67 {
74     ui d=vvars[1];
75     for(ui i=0;i<N;i++) particles[i]\&.dx[d]=dx[i];
76     import_vel(argv\&.\&.\&.);
77 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::import_vel (\fBui\fP i, \fBldf\fP dx)"

.PP
Load velocity for i from value\&. This function takes an arbitrary number of values\&. 
.br
 The values are then then assigned to the \fCd\fPth component of the \fCi\fPth particle's velocity 
.br
 As \fCd\fP is a variadic variable it is stored and increased for every value\&.
.PP
Definition at line 79 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
80 {
86     ui d=vvars[1];
87     particles[i]\&.dx[d]=dx;
88 }
.fi
.SS "template<ui dim> template<typename\&.\&.\&. arg> void \fBmd\fP< dim >::import_vel (\fBui\fP i, \fBldf\fP dx, arg\&.\&.\&. argv)"

.PP
Load velocity for i from value\&. This function takes an arbitrary number of values\&. 
.br
 The values are then then assigned to the \fCd\fPth component of the \fCi\fPth particle's velocity
.br
 As \fCd\fP is a variadic variable it is stored and increased for every value\&.
.PP
Definition at line 90 of file importexport\&.md\&.libmd\&.cc\&.
.PP
.nf
91 {
97     ui d=vvars[1];
98     particles[i]\&.dx[d]=dx;
99     import_vel(i,argv\&.\&.\&.);
100 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::index"

.PP
Find neighbors\&. This function finds all the pairs of particles that are within \fCnetwork\&.ssz\fP of each other and have an interaction\&. They are then put in each other's skinlist (\fCnetwork\&.skins[]\fP)\&.
.br
 It calls the algorithm specificied by \fCindexdata\&.method\fP: \fBmd<dim>::bruteforce()\fP, \fBmd<dim>::kdtree()\fP or \fBmd<dim>::cell()\fP\&.
.PP
Definition at line 14 of file index\&.md\&.libmd\&.cc\&.
.PP
.nf
15 {
21     for(ui i=0;i<N;i++) thread_index_stick(i);
22     switch(indexdata\&.method)
23     {
24         case INDEX::BRUTE_FORCE:
25             bruteforce();
26         break;
27         case INDEX::KD_TREE:
28             kdtree();
29         break;
30         default:
31             cell();
32         break;
33     }
34     avars\&.reindex=false;
35 }
.fi
.PP
References INDEX::BRUTE_FORCE, and INDEX::KD_TREE\&.
.SS "template<ui dim> void \fBmd\fP< dim >::init (\fBui\fP particlenr)"

.PP
Copy of the particle number constructor\&. Initialize \fBmd\fP structure for a given number of particles specified by \fCparticlenr\fP\&. Resizes all lists of structures that require one element per particle\&.
.PP
Definition at line 16 of file md\&.libmd\&.cc\&.
.PP
.nf
17 {
23     N=particlenr;
24     DEBUG_1("creating md<" F_UI "> with " F_UI " particles",dim,N);
25     if(N)
26     {
27         particles\&.resize(N);
28         network\&.skins\&.resize(N);
29         network\&.forces\&.resize(N);
30         network\&.spid\&.resize(N);
31         for(ui i=0;i<N;i++) network\&.spid[i]=UI_MAX;
32     }
33     avars\&.export_force_calc=true;
34 }
.fi
.PP
References DEBUG_1, F_UI, and UI_MAX\&.
.SS "template<ui dim> void \fBmd\fP< dim >::integrate\fC [virtual]\fP"

.PP
Integrate particle trajectoriess\&. This function calls one of the specified available integrators depending on the value of md<dim>::integrator\&.method\&. 
.br
 The default call is symplectic Euler (see \fBmd<dim>::thread_seuler\fP)\&.
.PP
Reimplemented in \fBmpmd< dim >\fP\&.
.PP
Definition at line 75 of file integrator\&.md\&.libmd\&.cc\&.
.PP
.nf
76 {
81     avars\&.export_force_calc=true;
82     switch(integrator\&.method)
83     {
84         case INTEGRATOR::FO_OVERDAMPED:
85             DEBUG_2("integrating using overdamped first order (Euler)");
86             for(ui i=0;i<N;i++) if(!particles[i]\&.fix) thread_overdamped(i);
87         break;
88         case INTEGRATOR::FO:
89             DEBUG_2("integrating using first order (Euler)");
90             for(ui i=0;i<N;i++) if(!particles[i]\&.fix) thread_first_order(i);
91         break;
92         case INTEGRATOR::VVERLET:
93             DEBUG_2("integrating using symplectic Velocity Verlet");
94             for(ui i=0;i<N;i++) if(!particles[i]\&.fix) thread_vverlet_x(i);
95             recalc_forces();
96             for(ui i=0;i<N;i++) if(!particles[i]\&.fix) thread_vverlet_dx(i);
97         break;
98         default:
99             DEBUG_2("integrating using symplectic Euler method");
100             for(ui i=0;i<N;i++) if(!particles[i]\&.fix) thread_seuler(i);
101         break;
102     }
103     periodicity();
104 }
.fi
.PP
References DEBUG_2, INTEGRATOR::FO, INTEGRATOR::FO_OVERDAMPED, and INTEGRATOR::VVERLET\&.
.SS "template<ui dim> void \fBmd\fP< dim >::interactions (\fBui\fP i, std::vector< std::pair< \fBui\fP, \fBui\fP >> & table)"

.PP
Dump interactions of a certain particle into a table\&. This function puts a list of all interaction neighbors of particle \fCi\fP in \fCtable\fP, as pairs of particles with \fCi\fP being the first\&.
.PP
Definition at line 6 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
7 {
12     table\&.clear();
13     for(auto sij: network\&.skins[i]) if(distsq(i,sij\&.neighbor)<std::pow(get_rco(sij\&.interaction),2)) table\&.push_back(std::pair<ui,ui>(i,sij\&.neighbor));
14 }
.fi
.PP
References pow()\&.
.SS "template<ui dim> void \fBmd\fP< dim >::kdtree"

.PP
k-d tree indexing algorithm This indexing function uses a k-d tree (a multidimensional binary tree)\&.
.br
 It makes use of the recursive functions \fBmd<dim>::kdtree_build()\fP and \fBmd<dim>::kdtree_index()\fP\&.
.br
 It does not work if there is both shear and a dimension with periodic boundary conditions\&.
.PP
Definition at line 140 of file index\&.md\&.libmd\&.cc\&.
.PP
.nf
141 {   
142     if (simbox\&.useLshear)
147         for (ui d = 0; d < dim; d++)
148             if (simbox\&.bcond[d] == BCOND::PERIODIC || simbox\&.bcond[d] == BCOND::BOXSHEAR)
149             {   ERROR("the kd-tree algorithm does not work with both shear and periodic boundary conditions");
150                 return;
151             }
152     if (indexdata\&.kdtreedata\&.Idx == nullptr || sizeof(indexdata\&.kdtreedata\&.Idx) != N*sizeof(ui))
153     {   delete[] indexdata\&.kdtreedata\&.Idx;
154         delete[] indexdata\&.kdtreedata\&.Pmin;
155         delete[] indexdata\&.kdtreedata\&.Pmax;
156         indexdata\&.kdtreedata\&.Idx = new ui[N];
157         indexdata\&.kdtreedata\&.Pmin = new ldf[N][dim];
158         indexdata\&.kdtreedata\&.Pmax = new ldf[N][dim];
159     }
160     ldf S[dim];
161     ui i, n, d, b;
162     for (i = 0; i < N; i++)
163         indexdata\&.kdtreedata\&.Idx[i] = i;
164     // Decide on which dimensions to divide the particles by at each recursion level
165     memcpy(S, simbox\&.L, sizeof(S));
166     for (i = 0, n = N; n > 1; i++, n = (n+1)/2)
167     {   // Look for largest dimension
168         b = 0;
169         for (d = 1; d < dim; d++)
170             if (S[b] < S[d])
171                 b = d;
172         indexdata\&.kdtreedata\&.DivideByDim[i] = b;
173         S[b] /= 2; // Assume that the system is nicely split into two parts
174     }
175     kdtree_build(0, N, 0);
176     for (i = 0; i < N; i++)
177         network\&.skins[i]\&.clear();
178     kdtree_index(0, N, 0, N);
179 }
.fi
.PP
References BCOND::BOXSHEAR, ERROR, and BCOND::PERIODIC\&.
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::kdtree_build (\fBui\fP first, \fBui\fP last, \fBui\fP level)"

.PP
k-d tree indexing algorithm: tree build function (recursive) This function recursively builds the k-d tree, to be used by \fBmd<dim>::kdtree()\fP\&.
.br
 The particles in the subtree marked by \fCfirst\fP and \fClast\fP at recursion depth \fClevel\fP are split into two subtrees of (about) equal size\&. The particles in one subtree have a lower value of their position coordinate in a given dimension than the particles in the other subtree\&. The dimension is specified by \fCindexdata\&.kdtreedata\&.DivideByDim[level]\fP, which is set by \fBmd<dim>::kdtree()\fP\&. The two subtrees are build recursively\&.
.PP
Definition at line 60 of file index\&.md\&.libmd\&.cc\&.
.PP
.nf
61 {   
62     if (last - first == 1) // Leaf
70     {   // Set minimum and maximum value equal to the position of this particle (Idx[first])
71         memcpy(indexdata\&.kdtreedata\&.Pmin[first], particles[indexdata\&.kdtreedata\&.Idx[first]]\&.x, dim*sizeof(ldf));
72         memcpy(indexdata\&.kdtreedata\&.Pmax[first], particles[indexdata\&.kdtreedata\&.Idx[first]]\&.x, dim*sizeof(ldf));
73         return first;
74     }
75     ui m = (first+last)/2; // Median
76     ui sortedDim = indexdata\&.kdtreedata\&.DivideByDim[level];
77     // Put the index of particle with the median value of coordinate dim in its right place,
78     // put all particles with lower values below, and all with higher values above
79     std::nth_element(indexdata\&.kdtreedata\&.Idx+first, indexdata\&.kdtreedata\&.Idx+m, indexdata\&.kdtreedata\&.Idx+last,
80                 [=](ui i, ui j) -> bool { return particles[i]\&.x[sortedDim]<particles[j]\&.x[sortedDim];});
81     // Recursively build subtrees
82     ui m1 = kdtree_build(first, m, level+1), m2 = kdtree_build(m, last, level+1), d;
83     // Determine minimum and maximum value of each coordinate
84     for (d = 0; d < dim; d++)
85     {   indexdata\&.kdtreedata\&.Pmin[m][d] = std::min(indexdata\&.kdtreedata\&.Pmin[m1][d], indexdata\&.kdtreedata\&.Pmin[m2][d]);
86         indexdata\&.kdtreedata\&.Pmax[m][d] = std::max(indexdata\&.kdtreedata\&.Pmax[m1][d], indexdata\&.kdtreedata\&.Pmax[m2][d]);
87     }
88     return m;
89 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::kdtree_index (\fBui\fP first1, \fBui\fP last1, \fBui\fP first2, \fBui\fP last2)"

.PP
k-d tree indexing algorithm: neighbor finder (recursive) This function recursively finds neighboring particles, one from subtree 1, the other from subtree 2 (possibly the same subtree)\&.
.br
 First it is checked if the subtrees are too far apart; nothing is done then\&. Otherwise, the function is called for every combination of subtrees\&. When a leaf is reached, the single particle is checked against the particle\fB\fP(s) in the other subtree\&.
.PP
Definition at line 91 of file index\&.md\&.libmd\&.cc\&.
.PP
.nf
92 {
99     ui m1 = (first1+last1)/2, m2 = (first2+last2)/2, d;
100     ldf sszsq = std::pow(network\&.ssz,2);
101     // Base cases
102     if (m1 == first1 || m2 == first2) // A single particle
103     {   // Note: the other subtree contains either one or two particles
104         if (m1 != m2)
105             skinner(indexdata\&.kdtreedata\&.Idx[m1], indexdata\&.kdtreedata\&.Idx[m2], sszsq);
106         if (m2 != first2)
107             skinner(indexdata\&.kdtreedata\&.Idx[m1], indexdata\&.kdtreedata\&.Idx[first2], sszsq);
108         if (m1 != first1)
109             skinner(indexdata\&.kdtreedata\&.Idx[first1], indexdata\&.kdtreedata\&.Idx[m2], sszsq);
110         return;
111     }
112     // Compute distance (squared) between subtrees
113     if (m1 != m2) // Note: m1 == m2 iff the subtrees are the same
114     {   ldf dissqBetweenSubtrees = 0;
115         for (d = 0; d < dim; d++)
116         {   if (simbox\&.bcond[d] == BCOND::PERIODIC)
117             {   if (indexdata\&.kdtreedata\&.Pmin[m1][d] > indexdata\&.kdtreedata\&.Pmax[m2][d])
118                     dissqBetweenSubtrees += std::pow(std::min(indexdata\&.kdtreedata\&.Pmin[m1][d] - indexdata\&.kdtreedata\&.Pmax[m2][d],
119                                                     simbox\&.L[d] + indexdata\&.kdtreedata\&.Pmin[m2][d] - indexdata\&.kdtreedata\&.Pmax[m1][d]), 2);
120                 else if (indexdata\&.kdtreedata\&.Pmin[m2][d] > indexdata\&.kdtreedata\&.Pmax[m1][d])
121                     dissqBetweenSubtrees += std::pow(std::min(indexdata\&.kdtreedata\&.Pmin[m2][d] - indexdata\&.kdtreedata\&.Pmax[m1][d],
122                                                     simbox\&.L[d] + indexdata\&.kdtreedata\&.Pmin[m1][d] - indexdata\&.kdtreedata\&.Pmax[m2][d]), 2);
123             }
124             else if (indexdata\&.kdtreedata\&.Pmin[m1][d] > indexdata\&.kdtreedata\&.Pmax[m2][d])
125                 dissqBetweenSubtrees += std::pow(indexdata\&.kdtreedata\&.Pmin[m1][d] - indexdata\&.kdtreedata\&.Pmax[m2][d], 2);
126             else if (indexdata\&.kdtreedata\&.Pmin[m2][d] > indexdata\&.kdtreedata\&.Pmax[m1][d])
127                 dissqBetweenSubtrees += std::pow(indexdata\&.kdtreedata\&.Pmin[m2][d] - indexdata\&.kdtreedata\&.Pmax[m1][d], 2);
128         }
129         if (dissqBetweenSubtrees >= sszsq) // Return if the subtrees are too far apart
130             return;
131     }
132     // Recursively check subtrees
133     kdtree_index(first1, m1, first2, m2);
134     kdtree_index(first1, m1, m2, last2);
135     if (m1 != m2)
136         kdtree_index(m1, last1, first2, m2);
137     kdtree_index(m1, last1, m2, last2);
138 }
.fi
.PP
References BCOND::PERIODIC, and pow()\&.
.SS "template<ui dim> void \fBmd\fP< dim >::mad_bond (\fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"

.PP
Force add/modify bond\&. Same as \fBmd<dim>::add_bond(ui p1, ui p2, ui interaction)\fP, but performs no checks\&. 
.br

.br
 \fBWarning:\fP Assumes that the specified interaction type actually exists, and replaces any previously defined interaction between \fCp1\fP and \fCp2\fP\&.
.PP
Definition at line 115 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
116 {
125     assign_unique_types(p1, p2);
126     network\&.lookup[network\&.hash(particles[p1]\&.type,particles[p2]\&.type)]=interaction;
127     update_skins(p1,p2);
128 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::mad_bond (\fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > & parameters)"

.PP
Force add/modify bond\&. Same as \fBmd<dim>::add_bond(ui p1, ui p2, ui potential, std::vector<ldf> &parameters)\fP, but performs no checks\&. 
.br

.br
 \fBWarning:\fP Replaces any previously defined interaction between \fCp1\fP and \fCp2\fP\&.
.PP
Definition at line 171 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
172 {
180     mad_bond(p1, p2, add_interaction(potential, parameters));
181 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::mad_sp_bond (\fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"

.PP
Force add/modify superparticle bond\&. This function creates a new superparticle type and assigns it to the superparticle that \fCp1\fP and \fCp2\fP belong to\&. It then assigns an interaction to the two particles, using element \fCinteraction\fP from \fCnetwork\&.library[]\fP\&. It does not perform any checks\&.
.PP
Definition at line 299 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
300 {
306     ui spi = network\&.spid[p1];
307     std::pair<ui,ui> id = network\&.hash(network\&.superparticles[spi]\&.particles[p1], network\&.superparticles[spi]\&.particles[p2]);
308     network\&.sptypes[clone_sptype(spi)]\&.splookup[id] = interaction;
309     update_skins(p1,p2);
310 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::mad_sp_bond (\fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > & parameters)"

.PP
Force add/modify superparticle bond\&. This function creates a new superparticle type and assigns it to the superparticle that \fCp1\fP and \fCp2\fP belong to\&. It then assigns an interaction to the two particles, using a new interaction of the given type and with the given parameters\&. It does not perform any checks\&.
.PP
Definition at line 350 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
351 {
357     ui spi = network\&.spid[p1];
358     std::pair<ui,ui> id = network\&.hash(network\&.superparticles[spi]\&.particles[p1], network\&.superparticles[spi]\&.particles[p2]);
359     network\&.sptypes[clone_sptype(spi)]\&.splookup[id] = add_interaction(potential, parameters);
360     update_skins(p1,p2);
361 }
.fi
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::mad_sp_interaction (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"

.PP
Force add/mod superparticle interaction rule\&. This function assigns an interaction to particle numbers \fCp1\fP and \fCp2\fP of superparticles of type \fCspt\fP, using element \fCinteraction\fP from \fCnetwork\&.library[]\fP\&. If the given superparticletype does not exist, a new one is added to \fCnetwork\&.sptypes[]\fP\&. It returns the index of the superparticletype (which is \fCspt\fP or the index of the newly created one)\&. It does not perform any checks\&.
.PP
Definition at line 368 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
369 {
377     if (spt >= network\&.sptypes\&.size())
378     {   spt = network\&.sptypes\&.size();
379         network\&.sptypes\&.push_back(superparticletype());
380     }
381     network\&.sptypes[spt]\&.splookup[network\&.hash(p1,p2)] = interaction;
382     avars\&.reindex=true;
383     return spt;
384 }
.fi
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::mad_sp_interaction (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > & parameters)"

.PP
Force add/mod superparticle interaction rule\&. This function assigns an interaction to particle numbers \fCp1\fP and \fCp2\fP of superparticles of type \fCspt\fP, using a new interaction of the given type and with the given parameters\&. If the given superparticletype does not exist, a new one is added to \fCnetwork\&.sptypes[]\fP\&. It returns the index of the superparticletype (which is \fCspt\fP or the index of the newly created one)\&. It does not perform any checks\&.
.PP
Definition at line 472 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
473 {
481     if (spt >= network\&.sptypes\&.size())
482     {
483         spt = network\&.sptypes\&.size();
484         network\&.sptypes\&.push_back(superparticletype());
485     }
486     network\&.sptypes[spt]\&.splookup[network\&.hash(p1,p2)] = add_interaction(potential,rco,parameters);
487     avars\&.reindex=true;
488     return spt;
489 }
.fi
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::mad_sp_interaction (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > & parameters)"

.PP
Force add/mod superparticle interaction rule\&. This function assigns an interaction to particle numbers \fCp1\fP and \fCp2\fP of superparticles of type \fCspt\fP, using a new interaction of the given type and with the given parameters\&. If the given superparticletype does not exist, a new one is added to \fCnetwork\&.sptypes[]\fP\&. It returns the index of the superparticletype (which is \fCspt\fP or the index of the newly created one)\&. It does not perform any checks\&.
.PP
Definition at line 460 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
461 {
469     return mad_sp_interaction(spt,p1,p2,potential,network\&.rco,parameters);
470 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::mad_typeinteraction (\fBui\fP type1, \fBui\fP type2, \fBui\fP interaction)"

.PP
Force add/mod type interaction rule\&. This function assigns a type interaction to the given pair of types, using element \fCinteraction\fP from \fCnetwork\&.library[]\fP\&. It does not perform any checks\&.
.PP
Definition at line 172 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
173 {
178     network\&.lookup[network\&.hash(type1,type2)]=interaction;
179     avars\&.reindex=true;
180 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::mad_typeinteraction (\fBui\fP type1, \fBui\fP type2, \fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > & parameters)"

.PP
Force add/mod type interaction rule\&. This function assigns a type interaction to the given pair of types, using a new interaction of the given type and with the given parameters\&. It does not perform any checks\&.
.PP
Definition at line 245 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
246 {
251     network\&.lookup[network\&.hash(type1,type2)]=add_interaction(potential,rco,parameters);
252     avars\&.reindex=true;
253 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::mad_typeinteraction (\fBui\fP type1, \fBui\fP type2, \fBui\fP potential, std::vector< \fBldf\fP > & parameters)"

.PP
Force add/mod type interaction rule\&. This function assigns a type interaction to the given pair of types, using a new interaction of the given type and with the given parameters\&. It does not perform any checks\&.
.PP
Definition at line 236 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
237 {
242     mad_typeinteraction(type1,type2,potential,network\&.rco,parameters);
243 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_bond (\fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"

.PP
Modify a bond\&. This function modifies any previous interaction between particles \fCp1\fP and \fCp2\fP, and turns it into a bond of previously-defined interaction type specified in the third argument\&. (See the \fBInteractions\fP documentation for more information on interaction types\&.) 
.br

.br
 Does nothing and returns false if one of the following holds: 
.PD 0

.IP "\(bu" 2
no interaction exists between \fCp1\fP and \fCp2\fP, 
.IP "\(bu" 2
the interaction specified by the third argument does not exist or was previously removed\&. 
.PP
Otherwise, creates a bond of the specified type between \fCp1\fP and \fCp2\fP, and returns \fCtrue\fP\&.
.PP
Definition at line 79 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
80 {
95     if (!network\&.lookup\&.count(network\&.hash(particles[p1]\&.type,particles[p2]\&.type)))
96         return false;
97     else if(interaction>=network\&.library\&.size())
98     {
99         WARNING("interaction %d does not exist", interaction);
100         return false;
101     }
102     else if(network\&.free_library_slots\&.count(interaction))
103     {
104         WARNING("interaction %d was previously removed", interaction);
105         return false;
106     }
107     else
108     {   assign_unique_types(p1, p2);
109         network\&.lookup[network\&.hash(particles[p1]\&.type,particles[p2]\&.type)]=interaction;
110         update_skins(p1,p2);
111         return true;
112     }
113 }
.fi
.PP
References WARNING\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_bond (\fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > & parameters)"

.PP
Modify a bond\&. This function modifies any previous interaction between particles \fCp1\fP and \fCp2\fP into a pair-specific bond with the potential type and parameters specified in the arguments\&. (See the \fBInteractions\fP documentation for more information on potential types and passing parameters\&.) 
.br

.br
 Does nothing if an interaction already exists between \fCp1\fP and \fCp2\fP, and returns \fCfalse\fP\&. Otherwise, creates a bond of the specified type between \fCp1\fP and \fCp2\fP, and returns \fCtrue\fP\&.
.PP
Definition at line 150 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
151 {
163     if (!network\&.lookup\&.count(network\&.hash(particles[p1]\&.type,particles[p2]\&.type)))
164         return false;
165     else
166     {   mad_bond(p1, p2, add_interaction(potential, parameters));
167         return true;
168     }
169 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_forcetype (\fBui\fP ftype, \fBui\fP force, std::vector< \fBldf\fP > & parameters)"

.PP
Modify force type\&. This function replaces the forcetype in \fCnetwork\&.forcelibrary[]\fP with index \fCftype\fP with a forcetype of the given type and with the given parameters\&. It returns whether the given forcelibrary element exists\&.
.PP
Definition at line 532 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
533 {
539     if(ftype<network\&.forcelibrary\&.size())
540     {
541         forcetype temp(force,parameters);
542         network\&.forcelibrary[ftype]=temp;
543         return true;
544     }
545     else return false;
546 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_forcetype (\fBui\fP ftype, \fBui\fP force, std::vector< std::vector< \fBui\fP >> & plist, std::vector< \fBldf\fP > & parameters)"

.PP
Modify force type plist\&. This function replaces the forcetype in \fCnetwork\&.forcelibrary[]\fP with index \fCftype\fP with a forcetype of the given type and with the given parameters\&. It returns whether the given forcelibrary element exists\&.
.PP
Definition at line 548 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
549 {
555     if(ftype<network\&.forcelibrary\&.size())
556     {
557         forcetype temp(force,plist,parameters);
558         network\&.forcelibrary[ftype]=temp;
559         return true;
560     }
561     else return false;
562 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_hook (\fBui\fP htype, \fBui\fP nohook, std::vector< \fBldf\fP > & parameters)"

.PP
Modify a hook\&. This function replaces the forcetype in \fChook\&.hookers[]\fP with index \fChtype\fP with a forcetype of the given type and with the given parameters\&. It returns whether the given forcelibrary element exists\&.
.PP
Definition at line 16 of file hooks\&.md\&.libmd\&.cc\&.
.PP
.nf
17 {
23     if(htype<hooks\&.hookers\&.size())
24     {
25         hooktype temp(hook,parameters);
26         hooks\&.hookers[htype]=temp;
27         return true;
28     }
29     else return false;
30 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_interaction (\fBui\fP interaction, \fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > & parameters)"

.PP
Modify type interaction rule\&. This function replaces the interaction in \fCnetwork\&.library[]\fP with index \fCinteraction\fP with a potential of the given type and with the given parameters\&. It returns whether the given library element exists\&.
.PP
Definition at line 63 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
64 {
70     if(interaction>=network\&.library\&.size())
71     {
72         WARNING("interaction %d does not exist", interaction);
73         return false;
74     }
75     else if(network\&.free_library_slots\&.count(interaction))
76     {
77         WARNING("interaction %d was previously removed", interaction);
78         return false;
79     }
80     else
81     {
82         interactiontype itype(potential,parameters,rco,v(potential,rco,parameters));
83         network\&.library[interaction]=itype;
84         avars\&.reindex=true;
85         return true;
86     }
87 }
.fi
.PP
References WARNING\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_interaction (\fBui\fP interaction, \fBui\fP potential, std::vector< \fBldf\fP > & parameters)"

.PP
Modify type interaction rule\&. This function replaces the interaction in \fCnetwork\&.library[]\fP with index \fCinteraction\fP with a potential of the given type and with the given parameters\&. It returns whether the given library element exists\&.
.PP
Definition at line 53 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
54 {
60     return mod_interaction(interaction,potential,network\&.rco,parameters);
61 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_sp_bond (\fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"

.PP
Modify a superparticle bond\&. This function creates a new superparticle type and assigns it to the superparticle that \fCp1\fP and \fCp2\fP belong to\&. It then modifies the interaction between the two particles, using element \fCinteraction\fP from \fCnetwork\&.library[]\fP\&. If the two particles are not in the same superparticle, or do not have an interaction already, it does nothing and returns false\&.
.PP
Definition at line 280 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
281 {
287     ui spi = network\&.spid[p1];
288     if (spi == UI_MAX || spi != network\&.spid[p2])
289         return false;
290     ui spt = network\&.superparticles[spi]\&.sptype;
291     std::pair<ui,ui> id = network\&.hash(network\&.superparticles[spi]\&.particles[p1], network\&.superparticles[spi]\&.particles[p2]);
292     if (!network\&.sptypes[spt]\&.splookup\&.count(id))
293         return false;
294     network\&.sptypes[clone_sptype(spi)]\&.splookup[id] = interaction;
295     update_skins(p1,p2);
296     return true;
297 }
.fi
.PP
References UI_MAX\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_sp_bond (\fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > & parameters)"

.PP
Modify a superparticle bond\&. This function creates a new superparticle type and assigns it to the superparticle that \fCp1\fP and \fCp2\fP belong to\&. It then modifies the interaction between the two particles, using a new interaction of the given type and with the given parameters\&. If the two particles are not in the same superparticle, or do not have an interaction already, it does nothing and returns false\&.
.PP
Definition at line 331 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
332 {
338     ui spi = network\&.spid[p1];
339     if (spi == UI_MAX || spi != network\&.spid[p2])
340         return false;
341     ui spt = network\&.superparticles[spi]\&.sptype;
342     std::pair<ui,ui> id = network\&.hash(network\&.superparticles[spi]\&.particles[p1], network\&.superparticles[spi]\&.particles[p2]);
343     if (!network\&.sptypes[spt]\&.splookup\&.count(id))
344         return false;
345     network\&.sptypes[clone_sptype(spi)]\&.splookup[id] = add_interaction(potential, parameters);
346     update_skins(p1,p2);
347     return true;
348 }
.fi
.PP
References UI_MAX\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_sp_interaction (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP interaction)"

.PP
Modify superparticle interaction rule\&. This function modifies the interaction between particle numbers \fCp1\fP and \fCp2\fP of superparticles of type \fCspt\fP, using element \fCinteraction\fP from \fCnetwork\&.library[]\fP\&. It returns whether the given superparticletype and interaction exist and the particle numbers already had an interaction\&. If the two particle numbers do not already have an interaction, it is not added\&.
.PP
Definition at line 334 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
335 {
342     std::pair<ui,ui> id=network\&.hash(p1,p2);
343     if(spt>=network\&.sptypes\&.size())
344     {
345         WARNING("superparticletype %d does not exist", spt);
346         return false;
347     }
348     else if(!network\&.sptypes[spt]\&.splookup\&.count(id))
349         return false;
350     else if(interaction>=network\&.library\&.size())
351     {
352         WARNING("interaction %d does not exist", interaction);
353         return false;
354     }
355     else if(network\&.free_library_slots\&.count(interaction))
356     {
357         WARNING("interaction %d was previously removed", interaction);
358         return false;
359     }
360     else
361     {
362         network\&.sptypes[spt]\&.splookup[id]=interaction;
363         avars\&.reindex=true;
364         return true;
365     }
366 }
.fi
.PP
References WARNING\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_sp_interaction (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > & parameters)"

.PP
Modify superparticle interaction rule\&. This function modifies the interaction between particle numbers \fCp1\fP and \fCp2\fP of superparticles of type \fCspt\fP, using a new interaction of the given type and with the given parameters\&. It returns whether the given superparticletype and interaction exist and the particle numbers already had an interaction\&. If the two particle numbers do not already have an interaction, it is not added and the interaction is not added to \fCnetwork\&.library[]\fP\&.
.PP
Definition at line 435 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
436 {
444     std::pair<ui,ui> id=network\&.hash(p1,p2);
445     if(spt>=network\&.sptypes\&.size())
446     {
447         WARNING("superparticletype %d does not exist", spt);
448         return false;
449     }
450     else if(!network\&.sptypes[spt]\&.splookup\&.count(id))
451         return false;
452     else
453     {
454         network\&.sptypes[spt]\&.splookup[id] = add_interaction(potential,rco,parameters);
455         avars\&.reindex=true;
456         return true;
457     }
458 }
.fi
.PP
References WARNING\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_sp_interaction (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2, \fBui\fP potential, std::vector< \fBldf\fP > & parameters)"

.PP
Modify superparticle interaction rule\&. This function modifies the interaction between particle numbers \fCp1\fP and \fCp2\fP of superparticles of type \fCspt\fP, using a new interaction of the given type and with the given parameters\&. It returns whether the given superparticletype and interaction exist and the particle numbers already had an interaction\&. If the two particle numbers do not already have an interaction, it is not added and the interaction is not added to \fCnetwork\&.library[]\fP\&.
.PP
Definition at line 423 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
424 {
432     return mod_sp_interaction(spt,p1,p2,potential,network\&.rco,parameters);
433 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_typeinteraction (\fBui\fP type1, \fBui\fP type2, \fBui\fP interaction)"

.PP
Modify type interaction rule\&. This function modifies the type interaction between the given types, using element \fCinteraction\fP from \fCnetwork\&.library[]\fP\&. It returns whether the given interaction exists and the two types already had an interaction\&. If the two types do not already have an interaction, it is not added\&.
.PP
Definition at line 144 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
145 {
151     std::pair<ui,ui> id=network\&.hash(type1,type2);
152     if(!network\&.lookup\&.count(id))
153         return false;
154     else if(interaction>=network\&.library\&.size())
155     {
156         WARNING("interaction %d does not exist", interaction);
157         return false;
158     }
159     else if(network\&.free_library_slots\&.count(interaction))
160     {
161         WARNING("interaction %d was previously removed", interaction);
162         return false;
163     }
164     else
165     {
166         network\&.lookup[id]=interaction;
167         avars\&.reindex=true;
168         return true;
169     }
170 }
.fi
.PP
References WARNING\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_typeinteraction (\fBui\fP type1, \fBui\fP type2, \fBui\fP potential, \fBldf\fP rco, std::vector< \fBldf\fP > & parameters)"

.PP
Modify type interaction rule\&. This function modifies the type interaction between the given types, using a new interaction of the given type and with the given parameters\&. It returns whether the two types already had an interaction\&. If the two types do not already have an interaction, it is not added and the interaction is not added to \fCnetwork\&.library[]\fP\&.
.PP
Definition at line 219 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
220 {
226     std::pair<ui,ui> id=network\&.hash(type1,type2);
227     if(!network\&.lookup\&.count(id)) return false;
228     else
229     {
230         network\&.lookup[id]=add_interaction(potential,rco,parameters);
231         avars\&.reindex=true;
232         return true;
233     }
234 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::mod_typeinteraction (\fBui\fP type1, \fBui\fP type2, \fBui\fP potential, std::vector< \fBldf\fP > & parameters)"

.PP
Modify type interaction rule\&. This function modifies the type interaction between the given types, using a new interaction of the given type and with the given parameters\&. It returns whether the two types already had an interaction\&. If the two types do not already have an interaction, it is not added and the interaction is not added to \fCnetwork\&.library[]\fP\&.
.PP
Definition at line 209 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
210 {
216     return mod_typeinteraction(type1,type2,potential,network\&.rco,parameters);
217 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::periodicity"

.PP
Called after integration to keep the particle within the defined boundaries\&. Update positions and velocities of particles to respect the appropriate boundary conditions\&. 
.br
 This function loops through the \fCdim\fP dimensions, and updates the positions and velocities of all (non-fixed) particles that have passed through the boundary perpendicular to dimension \fCd\fP, based on the value of \fCsimbox\&.bcond[d]\fP\&.
.PP
Definition at line 26 of file periodicity\&.md\&.libmd\&.cc\&.
.PP
.nf
27 {
36     for(ui i=0;i<N;i++) if(!particles[i]\&.fix)
37     {
38         if(particles[i]\&.usepbcond) for(ui d=0;d<dim;d++) boundary(particles[i]\&.pbc[d],d,i,this);
39         else for(ui d=0;d<dim;d++) boundary(d,i,this);
40     }
41 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::recalc_forces\fC [virtual]\fP"

.PP
Recalculate the forces between interacting particles for Velocity Verlet\&. This function recalculates all the forces in the nessecary for the Velocity Verlet integrator\&. Unlike \fBmd<dim>::calc_forces\fP this function does not clear nor index\&.
.PP
Reimplemented in \fBmpmd< dim >\fP\&.
.PP
Definition at line 64 of file forces\&.md\&.libmd\&.cc\&.
.PP
.nf
65 {
70     DEBUG_3("exec is here");
71     if(!network\&.library\&.empty()) for(ui i=0;i<N;i++) thread_calc_pot_forces(i);
72     if(!network\&.forcelibrary\&.empty()) for(ui i=0;i<N;i++) thread_calc_ext_forces(i);
73 }
.fi
.PP
References DEBUG_3\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::rem_bond (\fBui\fP p1, \fBui\fP p2)"

.PP
Remove a bond from the system\&. If a prior interaction between particles \fCp1\fP and \fCp2\fP exists, removes it and returns \fCtrue\fP, else returns false\&.
.PP
Definition at line 183 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
184 {
190     if (!network\&.lookup\&.count(network\&.hash(particles[p1]\&.type,particles[p2]\&.type)))
191         return false;
192     else
193     {   assign_unique_types(p1,p2);
194         network\&.lookup\&.erase(network\&.hash(particles[p1]\&.type,particles[p2]\&.type));
195         update_skins(p1,p2);
196         return true;
197     }
198 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::rem_forcetype (\fBui\fP ftype)"

.PP
Delete force type\&. This function removes the forcetype with index \fCftype\fP from \fCnetwork\&.forcelibrary[]\fP\&. It returns whether the given forcelibrary element existed\&.
.br
 Note: the last forcetype in \fCnetwork\&.forcelibrary[]\fP takes the place of the old one\&.
.PP
Definition at line 564 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
565 {
571     ui pos=network\&.forcelibrary\&.size();
572     if(ftype<pos)
573     {
574         for(ui i=0;i<N;i++) for(ui j=network\&.forces[i]\&.size()-1;j<UI_MAX;j--) if(network\&.forces[i][j]==ftype)
575         {
576             network\&.forces[i][j]=network\&.forces[i]\&.back();
577             network\&.forces[i]\&.pop_back();
578             break;
579         }
580         if(ftype<pos-1)
581         {
582             network\&.forcelibrary[ftype]=network\&.forcelibrary\&.back();
583             for(ui i=0;i<N;i++) for(ui j=network\&.forces[i]\&.size()-1;j<UI_MAX;j--) if(network\&.forces[i][j]==pos-1) network\&.forces[i][j]=ftype;
584         }
585         network\&.forcelibrary\&.pop_back();
586         return true;
587     }
588     else return false;
589 }
.fi
.PP
References UI_MAX\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::rem_hook (\fBui\fP htype)"

.PP
Remove a hook\&. This function removes the forcetype with index \fChtype\fP from \fChook\&.hookers[]\fP\&. It returns whether the given forcelibrary element existed\&.
.br
 Note: the last forcetype in \fChook\&.hookers[]\fP takes the place of the old one\&.
.PP
Definition at line 32 of file hooks\&.md\&.libmd\&.cc\&.
.PP
.nf
33 {
39     ui pos=hooks\&.hookers\&.size();
40     if(htype<pos)
41     {
42         if(htype<pos-1) hooks\&.hookers[htype]=hooks\&.hookers\&.back();
43         hooks\&.hookers\&.pop_back();
44         return true;
45     }
46     else return false;
47 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::rem_interaction (\fBui\fP interaction)"

.PP
Delete type interaction rule\&. This function removes the interaction with index \fCinteraction\fP from \fCnetwork\&.library[]\fP\&. It returns whether the given library element existed\&.
.br
 The other interactions retain their index\&.
.PP
Definition at line 89 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
90 {
96     if(interaction>=network\&.library\&.size())
97     {
98         WARNING("interaction %d does not exist", interaction);
99         return false;
100     }
101     else if(network\&.free_library_slots\&.count(interaction))
102     {
103         WARNING("interaction %d was previously removed", interaction);
104         return false;
105     }
106     else
107     {
108         network\&.free_library_slots\&.insert(interaction);
109         for(auto it=network\&.lookup\&.begin();it!=network\&.lookup\&.end();) (it->second==interaction)?network\&.lookup\&.erase(it++):it++;
110         for(ui i=network\&.sptypes\&.size()-1;i<UI_MAX;i--) for(auto it=network\&.sptypes[i]\&.splookup\&.begin();it!=network\&.sptypes[i]\&.splookup\&.end();) (it->second==interaction)?network\&.sptypes[i]\&.splookup\&.erase(it++):it++;
111         avars\&.reindex=true;
112         return true;
113     }
114 }
.fi
.PP
References UI_MAX, and WARNING\&.
.SS "template<ui dim> void \fBmd\fP< dim >::rem_particle (\fBui\fP i)"

.PP
Remove a particle from the system\&. This function removes particle \fCi\fP and all references to it from the system\&.
.br
 Note: particle \fCN-1\fP becomes the new particle \fCi\fP (if $i<N-1$)\&.
.PP
Definition at line 76 of file particles\&.md\&.libmd\&.cc\&.
.PP
.nf
77 {
82     DEBUG_2("removing particle #" F_UI "",i);
83     if(network\&.spid[i]<UI_MAX)
84         network\&.superparticles[network\&.spid[i]]\&.particles\&.erase(i);
85     ui j, k, p;
86     if (i < N-1)
87     {   // swap particle to delete with last particle, to prevent changing index of all particles after particlenr, and then delete it
88         iter_swap(particles\&.begin()+i, particles\&.rbegin());
89         // update the network
90         iter_swap(network\&.skins\&.begin()+i, network\&.skins\&.rbegin());
91         iter_swap(network\&.forces\&.begin()+i, network\&.forces\&.rbegin());
92         // Modify skins
93         for (j = network\&.skins[i]\&.size()-1; j < UI_MAX; j--)
94         {   p = network\&.skins[i][j]\&.neighbor;
95             if (p == i)
96                 p = N-1;
97             for (k = network\&.skins[p]\&.size()-1; k < UI_MAX && network\&.skins[p][k]\&.neighbor != N-1; k--);
98             if (k > N)
99             {   ERROR("(formerly) last particle not found in skinlist of particle #%d", p);
100                 return;
101             }
102             network\&.skins[p][k]\&.neighbor = i;
103         }
104         // Modify superparticle
105         if ((network\&.spid[i] = network\&.spid[N-1]) < UI_MAX)
106         {   auto it = network\&.superparticles[network\&.spid[i]]\&.particles\&.find(N-1);
107             if (it == network\&.superparticles[network\&.spid[i]]\&.particles\&.end())
108             {   ERROR("particle #" F_UI " not found in superparticle #" F_UI "", N-1, network\&.spid[i]);
109                 return;
110             }
111             network\&.superparticles[network\&.spid[i]]\&.particles[i] = it->second;
112             network\&.superparticles[network\&.spid[i]]\&.backdoor[it->second] = i;
113             network\&.superparticles[network\&.spid[i]]\&.particles\&.erase(it);
114         }
115         for(auto ftype:network\&.forcelibrary) if(!ftype\&.particles\&.empty()) iter_swap(ftype\&.particles\&.begin()+i,ftype\&.particles\&.rbegin());
116     }
117     for(auto ftype:network\&.forcelibrary) if(!ftype\&.particles\&.empty())
118     {
119         ftype\&.particles\&.pop_back();
120         for(j=0;j<N-1;j++) for(k=ftype\&.particles[j]\&.size()-1;k<UI_MAX;k--) if(ftype\&.particles[j][k]==i)
121         {
122             iter_swap(ftype\&.particles[j]\&.begin()+k,ftype\&.particles[j]\&.rbegin());
123             ftype\&.particles[j]\&.pop_back();
124         }
125     }
126     if(i<N-1) for(auto ftype:network\&.forcelibrary) if(!ftype\&.particles\&.empty()) for(j=0;j<N-1;j++) for(k=ftype\&.particles[j]\&.size()-1;k<UI_MAX;k--) if(ftype\&.particles[j][k]==N-1) ftype\&.particles[j][k]=i;
127     // Modify skins
128     for (j = network\&.skins[N-1]\&.size()-1; j < UI_MAX; j--)
129     {   p = network\&.skins[N-1][j]\&.neighbor;
130         for (k = network\&.skins[p]\&.size()-1; k < UI_MAX && network\&.skins[p][k]\&.neighbor != i; k--);
131         if (k > N)
132         {   ERROR("particle to be deleted not found in skinlist of particle #%d", p);
133             return;
134         }
135         iter_swap(network\&.skins[p]\&.begin()+k, network\&.skins[p]\&.rbegin());
136         network\&.skins[p]\&.pop_back();
137     }
138     // Remove last particle
139     N--;
140     particles\&.pop_back();
141     network\&.skins\&.pop_back();
142     network\&.forces\&.pop_back();
143     network\&.spid\&.pop_back();
144     avars\&.reindex=true;
145 }
.fi
.PP
References DEBUG_2, ERROR, F_UI, and UI_MAX\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::rem_sp (\fBui\fP spi)"

.PP
Remove a superparticle (i\&.e\&. the structure, not the particles) This function removes the superparticle with index \fCspi\fP from \fCnetwork\&.superparticles[]\fP and resets the superparticle reference (\fCnetwork\&.spid[]\fP) of all its particles\&. It returns whether the given superparticle existed\&.
.br
 Note: the last superparticle in \fCnetwork\&.superparticles[]\fP takes the place of the removed one
.PP
Definition at line 18 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
19 {
26     if(spi>=network\&.superparticles\&.size())
27     {
28         WARNING("superparticle #%d does not exist", spi);
29         return false;
30     }
31     else
32     {
33         ui spn=network\&.superparticles\&.size()-1;
34         if(spi<spn)
35         {
36             for(auto m: network\&.superparticles[spn]\&.particles) network\&.spid[m\&.first]=spi;
37             iter_swap(network\&.superparticles\&.begin()+spi,network\&.superparticles\&.rbegin());
38         }
39         for(auto m: network\&.superparticles[spn]\&.particles) network\&.spid[m\&.first]=UI_MAX;
40         network\&.superparticles\&.pop_back();
41         DEBUG_2("removed superparticle #" F_UI "",spi);
42         return true;
43     }
44 }
.fi
.PP
References DEBUG_2, F_UI, UI_MAX, and WARNING\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::rem_sp_bond (\fBui\fP p1, \fBui\fP p2)"

.PP
Remove a superparticle bond from the system\&. This function creates a new superparticle type and assigns it to the superparticle that \fCp1\fP and \fCp2\fP belong to\&. It then removes the interaction between the two particles\&. If the two particles are not in the same superparticle, or do not have an interaction, it does nothing and returns false\&.
.PP
Definition at line 363 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
364 {
370     ui spi = network\&.spid[p1];
371     if (spi == UI_MAX || spi != network\&.spid[p2])
372         return false;
373     ui spt = network\&.superparticles[spi]\&.sptype;
374     std::pair<ui,ui> id = network\&.hash(network\&.superparticles[spi]\&.particles[p1], network\&.superparticles[spi]\&.particles[p2]);
375     if (!network\&.sptypes[spt]\&.splookup\&.count(id))
376         return false;
377     network\&.sptypes[clone_sptype(spi)]\&.splookup\&.erase(id);
378     update_skins(p1,p2);
379     return true;
380 }
.fi
.PP
References UI_MAX\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::rem_sp_interaction (\fBui\fP spt, \fBui\fP p1, \fBui\fP p2)"

.PP
Delete superparticle interaction rule\&. This function removes the interaction between particle numbers \fCp1\fP and \fCp2\fP of superparticles of type \fCspt\fP\&. It does not remove the interaction from\fCnetwork\&.library[]\fP\&. It returns whether the given superparticletype exists and the two particle numbers had an interaction\&.
.PP
Definition at line 491 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
492 {
498     if(spt>=network\&.sptypes\&.size())
499     {
500         WARNING("superparticletype %d does not exist", spt);
501         return false;
502     }
503     else
504     {
505         avars\&.reindex=true;
506         return network\&.sptypes[spt]\&.splookup\&.erase(network\&.hash(p1,p2));
507     }
508 }
.fi
.PP
References WARNING\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::rem_sp_particles (\fBui\fP spi)"

.PP
Remove all particles in a superparticle\&. This function removes all the particles of the superparticle with index \fCspi\fP from the system and clears the superparticle (but does not remove it)\&. It returns whether the given superparticle exists\&.
.PP
Definition at line 46 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
47 {
53     if(spi>=network\&.superparticles\&.size())
54     {
55         WARNING("superparticle #%d does not exist", spi);
56         return false;
57     }
58     else
59     {
60         ui k=0;
61         std::vector<ui> target(network\&.superparticles[spi]\&.particles\&.size());
62         for(auto m: network\&.superparticles[spi]\&.particles) target[k++]=m\&.first;
63         for(auto i: target) rem_particle(i);
64         network\&.superparticles[spi]\&.particles\&.clear();
65         network\&.superparticles[spi]\&.backdoor\&.clear();
66         DEBUG_2("removed particles of superparticle #" F_UI "",spi);
67         return true;
68     }
69 }
.fi
.PP
References DEBUG_2, F_UI, and WARNING\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::rem_sptype (\fBui\fP spt)"

.PP
Delete superparticletype\&. This function removes the superparticletype with index \fCspt\fP from \fCnetwork\&.sptypes[]\fP\&. It returns whether this element existed\&.
.br
 Note: the last superparticletype in \fCnetwork\&.sptypes[]\fP takes the place of the old one\&.
.PP
Definition at line 277 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
278 {
284     if(spt<network\&.sptypes\&.size())
285     {
286         ui spn=network\&.sptypes\&.size()-1;
287         for(ui i=network\&.superparticles\&.size()-1;i<UI_MAX;i--)
288         {
289             if(network\&.superparticles[i]\&.sptype==spt) network\&.superparticles[i]\&.sptype=UI_MAX;
290             if(network\&.superparticles[i]\&.sptype==spn) network\&.superparticles[i]\&.sptype=spt;
291         }
292         iter_swap(network\&.superparticles\&.begin()+spt,network\&.superparticles\&.rbegin());
293         network\&.sptypes\&.pop_back();
294         avars\&.reindex=true;
295         return true;
296     }
297     else return false;
298 }
.fi
.PP
References UI_MAX\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::rem_typeinteraction (\fBui\fP type1, \fBui\fP type2)"

.PP
Delete type interaction rule\&. This function removes the type interaction between the given types\&. It does not remove the interaction from\fCnetwork\&.library[]\fP\&. It returns whether the two types had an interaction\&.
.PP
Definition at line 255 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
256 {
261     avars\&.reindex=true;
262     return network\&.lookup\&.erase(network\&.hash(type1,type2));
263 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::run_hook (\fBui\fP htype)"

.PP
Run a certain hook\&. This function runs the hook with index \fChtype\fP from \fChook\&.hookers[]\fP\&.
.PP
Definition at line 49 of file hooks\&.md\&.libmd\&.cc\&.
.PP
.nf
50 {
54     if(htype<hooks\&.hookers\&.size())
55     {
56         hooks\&.hook(hooks\&.hookers[htype]\&.hook,hooks\&.hookers[htype]\&.parameters,this);
57         return true;
58     }
59     else return false;
60 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::run_hooks"

.PP
Run all hooks\&. This function runs all the hook in \fChook\&.hookers[]\fP\&.
.PP
Definition at line 62 of file hooks\&.md\&.libmd\&.cc\&.
.PP
.nf
63 {
67     for(hooktype htype:hooks\&.hookers) hooks\&.hook(htype\&.hook,htype\&.parameters,this);
68 }
.fi
.PP
References hooktype::hook, and hooktype::parameters\&.
.SS "template<ui dim> void \fBmd\fP< dim >::set_bcond (\fBuc\fP bcond[dim])"

.PP
Set the global boundary conditions\&. Sets the global boundary conditions
.PP
Definition at line 222 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
223 {
227     memcpy(simbox\&.bcond,bcond,dim*sizeof(uc));
228 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::set_damping (\fBldf\fP coefficient)"

.PP
Enables damping and sets damping coefficient\&. This function adds damping with the given coefficient, or changes the coefficient if damping was already set\&.
.PP
Definition at line 6 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
7 {
11     if(avars\&.noftypedamping==UI_MAX)
12     {
13         DEBUG_2("activating damping with damping coefficient: " F_LDF,coefficient);
14         std::vector<ldf> parameters(1,coefficient);
15         avars\&.noftypedamping=add_forcetype(EXTFORCE::DAMPING,parameters);
16         assign_all_forcetype(avars\&.noftypedamping);
17     }
18     else
19     {
20         DEBUG_2("modifying damping coefficient to: " F_LDF,coefficient);
21         network\&.forcelibrary[avars\&.noftypedamping]\&.parameters[0]=coefficient;
22     }
23 }
.fi
.PP
References EXTFORCE::DAMPING, DEBUG_2, F_LDF, and UI_MAX\&.
.SS "template<ui dim> void \fBmd\fP< dim >::set_index_method (\fBui\fP method)"

.PP
Set indexmethod\&. Sets the indexing method to \fCmethod\fP\&.
.PP
Definition at line 214 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
215 {
219     indexdata\&.method=method;
220 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::set_langevin (\fBldf\fP T, \fBldf\fP gamma)\fC [virtual]\fP"

.PP
Enables Langevin thermostat (and damping) and sets T and gamma (does not use metric) This function adds a Langevin thermostat with the given coefficient T and gamma, or changes the coefficient if it was already set\&.
.PP
Reimplemented in \fBmpmd< dim >\fP\&.
.PP
Definition at line 44 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
45 {
49     if(avars\&.noftypelangevin==UI_MAX)
50     {
51         DEBUG_2("activating langevin thermostat with temperature: " F_LDF " and damping coefficient: " F_LDF,T,gamma);
52         std::vector<ldf> parameters={T,gamma};
53         avars\&.noftypelangevin=add_forcetype(EXTFORCE::LANGEVIN,parameters);
54         assign_all_forcetype(avars\&.noftypelangevin);
55         set_damping(gamma);
56     }
57     else
58     {
59         DEBUG_2("modifying langevin coefficient T to: " F_LDF " and gamma to: " F_LDF,T,gamma);
60         network\&.forcelibrary[avars\&.noftypedamping]\&.parameters[0]=T;
61         network\&.forcelibrary[avars\&.noftypedamping]\&.parameters[0]=gamma;
62         set_damping(gamma);
63     }
64 }
.fi
.PP
References DEBUG_2, F_LDF, EXTFORCE::LANGEVIN, and UI_MAX\&.
.SS "template<ui dim> void \fBmd\fP< dim >::set_overdamped (\fBldf\fP coefficient)"

.PP
Enable overdamped dynamics (with First oder integration) This function changes the integrator to \fBINTEGRATOR::FO_OVERDAMPED\fP Using this function with \fBset_damping()\fP might result in unwanted results
.PP
Definition at line 87 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
88 {
93     avars\&.overdamped_gamma=coefficient;
94     if(avars\&.overdamped_pre_integrator!=INTEGRATOR::FO_OVERDAMPED) avars\&.overdamped_pre_integrator=integrator\&.method;
95     integrator\&.method=INTEGRATOR::FO_OVERDAMPED;
96     if(avars\&.noftypedamping<UI_MAX)
97     {
98         (void) coefficient;
99         WARNING("set_damping in the overdamped regime might produce unwanted results");
100     }
101 }
.fi
.PP
References INTEGRATOR::FO_OVERDAMPED, UI_MAX, and WARNING\&.
.SS "template<ui dim> void \fBmd\fP< dim >::set_pbcond (\fBui\fP i, \fBuc\fP bcond[dim], bool toggle = \fCtrue\fP)"

.PP
Set the boundary conditions for particle i\&. Sets particle's boundary conditions
.PP
Definition at line 230 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
231 {
235     particles[i]\&.usepbcond=toggle;
236     memcpy(particles[i]\&.pbc,bcond,dim*sizeof(uc));
237 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::set_position_sp (\fBui\fP spi, \fBldf\fP x[dim])"

.PP
Get center of mass of super particle\&. This function translates the superparticle with index \fCspi\fP such that its center of mass is at position \fCx[]\fP\&.
.PP
Definition at line 250 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
251 {
255     DEBUG_2("repositioning superparticle #" F_UI "",spi);
256     avars\&.export_force_calc=true;
257     ldf delx[dim];
258     get_position_sp(spi,delx);
259     for(ui d=0;d<dim;d++) delx[d]=x[d]-delx[d];
260     for(auto it=network\&.superparticles[spi]\&.particles\&.begin();it!=network\&.superparticles[spi]\&.particles\&.end();it++) translate_particle(it->first,delx);
261 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> void \fBmd\fP< dim >::set_rco (\fBldf\fP rco)"

.PP
Sets the cuttoff radius\&. Sets \fCnetwork\&.rco\fP, the interaction cut-off distance, to \fCrco\fP\&.
.PP
Definition at line 138 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
139 {
143     network\&.rco=rco;
144     for (auto itype: network\&.library) itype\&.vco = v(itype\&.potential,network\&.rco,itype\&.parameters);
145     if (network\&.rco > network\&.ssz)
146     {
147         WARNING("network\&.rco is now larger than network\&.ssz (" F_LDF " > " F_LDF ")",network\&.rco,network\&.ssz);
148     }
149 }
.fi
.PP
References F_LDF, and WARNING\&.
.SS "template<ui dim> void \fBmd\fP< dim >::set_rco (\fBui\fP interaction, \fBldf\fP rco)"

.PP
Sets the cuttoff radius\&. Sets \fCnetwork\&.rco\fP, the interaction cut-off distance, to \fCrco\fP\&.
.PP
Definition at line 151 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
152 {
156     auto itype=network\&.library[interaction];
157     itype\&.rco = rco;
158     itype\&.vco = v(itype\&.potential,rco,itype\&.parameters);
159     if (rco > network\&.ssz)
160     {
161         WARNING("this rco is now larger than network\&.ssz (" F_LDF " > " F_LDF ")",rco,network\&.ssz);
162     }
163 }
.fi
.PP
References F_LDF, and WARNING\&.
.SS "template<ui dim> void \fBmd\fP< dim >::set_reserve (\fBldf\fP ssz)"

.PP
Set reserve memory according to skin size\&. This function reserves space for the vectors in \fCnetwork\&.skins[]\fP, assuming that (approximately) all particles interact with each other\&.
.PP
Definition at line 182 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
183 {
188     set_reserve(ssz,N);
189 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::set_reserve (\fBldf\fP ssz, \fBui\fP M)"

.PP
Set reserve memory according to skin size and some arbitrary number of particles\&. This function reserves space for the vectors in \fCnetwork\&.skins[]\fP, the amount of space being based on the assumption that each particle has at most \fCM\fP particles it interacts with and they are uniformly distributed over the system\&.
.PP
Definition at line 191 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
192 {
198     ldf area=1\&.0;
199     for(ui d=0;d<dim;d++) area*=simbox\&.L[d];
200     const ldf vol=(std::pow(std::acos(-1\&.0),((ldf)dim)/2\&.0)/std::tgamma(1\&.0+((ldf)dim)/2\&.0))*std::pow(ssz,dim);
201     const ui fed=std::min(N-1,(ui)(((ldf)M)*(vol)/(area))*2+4);
202     DEBUG_1("reserved skin size set to " F_UI " skins",fed);
203     for(ui i=0;i<N;i++) network\&.skins[i]\&.reserve(fed);
204 }
.fi
.PP
References acos(), DEBUG_1, F_UI, and pow()\&.
.SS "template<ui dim> void \fBmd\fP< dim >::set_spbcond (\fBui\fP spi, \fBuc\fP bcond[dim], bool toggle = \fCtrue\fP)"

.PP
Set the boundary conditions for superparticle spi\&. Sets particle's boundary conditions for the superparticles
.PP
Definition at line 239 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
240 {
244     ui K=network\&.superparticles[spi]\&.backdoor\&.size(),i;
245     for(ui k=0;k<K;k++)
246     {
247         if((i=network\&.superparticles[spi]\&.backdoor[k])<UI_MAX)
248         {
249             particles[i]\&.usepbcond=toggle;
250             memcpy(particles[i]\&.pbc,bcond,dim*sizeof(uc));
251         }
252     }
253 }
.fi
.PP
References UI_MAX\&.
.SS "template<ui dim> void \fBmd\fP< dim >::set_ssz (\fBldf\fP ssz)"

.PP
Sets the skin size radius and its square\&. Sets \fCnetwork\&.ssz\fP, the skinsize, to \fCssz\fP and reserves space for \fCnetwork\&.skins[]\fP\&.
.PP
Definition at line 165 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
166 {
170     network\&.ssz=ssz;
171     set_reserve(ssz);
172     for(auto itype:network\&.library) if(itype\&.rco>network\&.ssz)
173     {
174         WARNING("rco of interaction %zu is now larger than network\&.ssz (" F_LDF " > " F_LDF ")",&itype-&network\&.library[0],itype\&.rco,network\&.ssz);
175     }
176     if(network\&.rco>network\&.ssz)
177     {
178         WARNING("network\&.rco is now larger than network\&.ssz (" F_LDF " > " F_LDF ")",network\&.rco,network\&.ssz);
179     }
180 }
.fi
.PP
References F_LDF, and WARNING\&.
.SS "template<ui dim> void \fBmd\fP< dim >::set_type (\fBui\fP p, \fBui\fP newtype)"

.PP
Update the type associated with particle p\&. Sets the type of particle \fCp\fP to \fCnewtype\fP\&.
.PP
Definition at line 206 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
207 {
211     particles[p]\&.type=newtype;
212 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::set_velocity_sp (\fBui\fP spi, \fBldf\fP dx[dim])"

.PP
Assign velocity to a super particle (all particles the same) This function sets the velocity of all particles belonging to the superparticle with index \fCspi\fP equal to \fCdx[]\fP\&.
.PP
Definition at line 263 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
264 {
268     DEBUG_2("setting velocity of superparticle #" F_UI "",spi);
269     for(auto it=network\&.superparticles[spi]\&.particles\&.begin();it!=network\&.superparticles[spi]\&.particles\&.end();it++) memcpy(particles[it->first]\&.dx,dx,dim*sizeof(ldf));
270 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> void \fBmd\fP< dim >::skinner (\fBui\fP i, \fBui\fP j, \fBldf\fP sszsq)"

.PP
Places interactionneighbor in skin\&. This function is used by the indexing algorithms\&. It checks if the squared distance between particles \fCi\fP and \fCj\fP is less than \fCsszsq\fP and if they have a (superparticle) type interaction; if so, it adds them (with the interaction) to each other's skinlist\&.
.br

.PP
Definition at line 382 of file index\&.md\&.libmd\&.cc\&.
.PP
.nf
383 {
389     if (distsq(i,j) > sszsq)
390         return;
391     const ui K=network\&.spid[i];
392     std::pair<ui,ui> it;
393     if(K<UI_MAX and K==network\&.spid[j] and network\&.sptypes[network\&.superparticles[K]\&.sptype]\&.splookup\&.count(it=network\&.hash(network\&.superparticles[K]\&.particles[i],network\&.superparticles[K]\&.particles[j])))
394     {
395         interactionneighbor in(j,network\&.sptypes[network\&.superparticles[K]\&.sptype]\&.splookup[it]);
396         network\&.skins[i]\&.push_back(in);
397         in\&.neighbor=i;
398         network\&.skins[j]\&.push_back(in);
399         DEBUG_3("super particle skinned (i,j)=(" F_UI "," F_UI ") in " F_UI " with interaction " F_UI "",i,j,K,network\&.sptypes[network\&.superparticles[K]\&.sptype]\&.splookup[it]);
400     }
401     else
402     {
403         it=network\&.hash(particles[i]\&.type,particles[j]\&.type);
404         if(network\&.lookup\&.count(it))
405         {
406             interactionneighbor in(j,network\&.lookup[it]);
407             network\&.skins[i]\&.push_back(in);
408             in\&.neighbor=i;
409             network\&.skins[j]\&.push_back(in);
410             DEBUG_3("normally skinned (i,j)=(" F_UI "," F_UI ") with interaction " F_UI "",i,j,network\&.lookup[it]);
411         }
412     }
413 }
.fi
.PP
References DEBUG_3, F_UI, interactionneighbor::neighbor, and UI_MAX\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::sp_dispose (\fBui\fP i)"

.PP
Remove a particle from a superparticle\&. This function removes particle \fCi\fP from its superparticle (but not from the system) It returns whether the given particle was in a superparticle\&.
.PP
Definition at line 110 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
111 {
116     ui spi=network\&.spid[i];
117     if(spi==UI_MAX) return false;
118     else
119     {
120         network\&.spid[i]=UI_MAX;
121         DEBUG_2("particle #" F_UI " is removed from superparticle #" F_UI "",i,spi);
122         ui j=network\&.superparticles[spi]\&.particles[i];
123         if(j==network\&.superparticles[spi]\&.backdoor\&.size()-1)
124         {
125             network\&.superparticles[spi]\&.backdoor\&.pop_back();
126             while(!network\&.superparticles[spi]\&.backdoor\&.empty() and network\&.superparticles[spi]\&.backdoor\&.back()==UI_MAX) network\&.superparticles[spi]\&.backdoor\&.pop_back();
127         }
128         else network\&.superparticles[spi]\&.backdoor[j]=UI_MAX;
129         network\&.superparticles[spi]\&.particles\&.erase(i);
130         avars\&.reindex=true;
131         return true;
132     }
133 }
.fi
.PP
References DEBUG_2, F_UI, and UI_MAX\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::sp_dispose_idx (\fBui\fP spi, \fBui\fP idx)"

.PP
Remove a particle from a superparticle\&. This function removes the particle from slot \fCidx\fP of the superparticle with index \fCspi\fP from the superparticle (but not from the system)\&. It returns whether the given superparticle exists and has a particle in the given slot\&.
.PP
Definition at line 135 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
136 {
142     if(spi>=network\&.superparticles\&.size())
143     {
144         WARNING("superparticle #" F_UI " does not exist",spi);
145         return false;
146     }
147     else if(idx>=network\&.superparticles[spi]\&.backdoor\&.size())
148     {
149         WARNING("superparticle #" F_UI " does not contain index #" F_UI "",spi,idx);
150         return false;
151     }
152     else
153     {
154         ui i=network\&.superparticles[spi]\&.backdoor[idx];
155         if(i<UI_MAX)
156         {
157             sp_dispose(i);
158             DEBUG_2("particle #" F_UI " is removed from superparticle #" F_UI "",i,spi);
159             return true;
160         }
161         else
162         {
163             WARNING("superparticle #" F_UI " does not contain index #" F_UI "",spi,idx);
164             return false;
165         }
166     }
167 }
.fi
.PP
References DEBUG_2, F_UI, UI_MAX, and WARNING\&.
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::sp_ingest (\fBui\fP spi, \fBui\fP i, \fBui\fP idx = \fC\fBUI_MAX\fP\fP)"

.PP
Add a particle to a superparticle\&. This function puts particle \fCi\fP in slot \fCidx\fP of the superparticle with index \fCspi\fP\&. If \fCidx\fP = \fCUI_MAX\fP, the index is set to highest index plus one\&. It returns the index\&. If the given superparticle does not exist, or the given particle is already in a superparticle, or the given slot is already taken, nothing is done and UI_MAX is returned\&.
.PP
Definition at line 71 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
72 {
80     if(spi>=network\&.superparticles\&.size())
81     {
82         WARNING("superparticle #%d does not exist", spi);
83         return UI_MAX;
84     }
85     else if(network\&.spid[i] < UI_MAX)
86     {
87         WARNING("particle #" F_UI " is already in superparticle #" F_UI "",i,network\&.spid[i]);
88         return UI_MAX;
89     }
90     else
91     {
92         if(idx>=network\&.superparticles[spi]\&.backdoor\&.size())
93         {
94             if(idx==UI_MAX) idx=network\&.superparticles[spi]\&.backdoor\&.size();
95             network\&.superparticles[spi]\&.backdoor\&.resize(idx+1,UI_MAX);
96         }
97         else if(network\&.superparticles[spi]\&.backdoor[idx]<UI_MAX)
98         {
99             WARNING("superparticle #" F_UI " already contains index #" F_UI "",spi,idx);
100             return UI_MAX;
101         }
102         network\&.spid[i]=spi;
103         network\&.superparticles[spi]\&.backdoor[idx]=i;
104         DEBUG_2("particle #" F_UI " is ingested by superparticle #" F_UI "",i,spi);
105         avars\&.reindex=true;
106         return network\&.superparticles[spi]\&.particles[i]=idx;
107     }
108 }
.fi
.PP
References DEBUG_2, F_UI, UI_MAX, and WARNING\&.
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::sp_pid (\fBui\fP spi, \fBui\fP idx)"

.PP
Reverse lookup of particle id in superparticle\&. This function returns the id of the particle in slot \fCidx\fP of the superparticle with index \fCspi\fP\&. If the superparticle does not exist or it does not have a particle in the given slot, it returns UI_MAX\&.
.PP
Definition at line 169 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
170 {
175     if(spi>=network\&.superparticles\&.size())
176     {
177         WARNING("superparticle #" F_UI " does not exist",spi);
178         return UI_MAX;
179     }
180     else if(idx>=network\&.superparticles[spi]\&.backdoor\&.size())
181     {
182         WARNING("superparticle #" F_UI " does not contain index #" F_UI "",spi,idx);
183         return UI_MAX;
184     }
185     else return network\&.superparticles[spi]\&.backdoor[idx];
186 }
.fi
.PP
References F_UI, UI_MAX, and WARNING\&.
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::T"

.PP
Measure kinetic energy\&. Returns the total kinetic energy of the system
.PP
Definition at line 53 of file energy\&.md\&.libmd\&.cc\&.
.PP
.nf
54 {
58     ldf retval=0\&.0;
59     for(ui i=0;i<N;i++) retval+=thread_T(i);
60     return retval;
61 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::test_index"

.PP
Test if we need to run the indexing algorithm\&. This function determines if re-indexing is necessary, based on the position of each particle at the last time of indexing (\fCxsk[]\fP): If no particle has moved by more than $(ssz-rco)/2$, then there is no pair of particles that were more than \fCnetwork\&.ssz\fP apart, but now less than \fCnetwork\&.rco\fP apart, so re-indexing is not necessary\&. Otherwise, re-indexing might be necessary and thus should be done\&.
.PP
Definition at line 37 of file index\&.md\&.libmd\&.cc\&.
.PP
.nf
38 {
45     ldf rcomax=0\&.0;
46     for(auto itype:network\&.library) rcomax=std::max(rcomax,itype\&.rco);
47     const ldf delta=std::pow(network\&.ssz-rcomax,2)/4\&.0;
48     for(ui i=0;i<N;i++)
49     {
50         ldf test=0\&.0;
51         for(ui d=0;d<dim;d++) test+=std::pow(dap(d,particles[i]\&.xsk[d]-particles[i]\&.x[d]),2);
52         if(test>delta) return true;
53     }
54     return false;
55 }
.fi
.PP
References pow()\&.
.SS "template<ui dim> void \fBmd\fP< dim >::thread_calc_ext_forces (\fBui\fP i)"

.PP
Calculate the forces for particle i>j with atomics\&. This function calculates the forces induced by external forces acting on particle \fCi\fP
.PP
Definition at line 40 of file forces\&.md\&.libmd\&.cc\&.
.PP
.nf
41 {
45     for(auto ftype: network\&.forces[i]) f(network\&.forcelibrary[ftype]\&.externalforce,i,network\&.forcelibrary[ftype]\&.particles[i],network\&.forcelibrary[ftype]\&.parameters,(md<dim>*)this);
46 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::thread_calc_pot_forces (\fBui\fP i)"

.PP
Calculate the forces for particle i>j with atomics\&. This function calculates the forces induced by the potentials acting on particle \fCi\fP
.PP
Definition at line 14 of file forces\&.md\&.libmd\&.cc\&.
.PP
.nf
15 {
19     for(auto sij: network\&.skins[i]) if(i>sij\&.neighbor)
20     {
21         const ldf rsq=distsq(i,sij\&.neighbor);
22         if(!network\&.update or rsq<std::pow(get_rco(sij\&.interaction),2))
23         {
24             const ldf r=std::sqrt(rsq);
25             DEBUG_3("r = " F_LDF,r);
26             const ldf dVdr=v\&.dr(network\&.library[sij\&.interaction]\&.potential,r,network\&.library[sij\&.interaction]\&.parameters);
27             DEBUG_3("dV/dr = " F_LDF,dVdr);
28             for(ui d=0;d<dim;d++)
29             {
30                 ldf F_i=dd(d,i,sij\&.neighbor)*dVdr/r;
31                 particles[i]\&.F[d]+=F_i;
32                 DEBUG_3("particles[" F_UI "]\&.F[" F_UI "] = " F_LDF,i,d,F_i);
33                 particles[sij\&.neighbor]\&.F[d]-=F_i;
34                 DEBUG_3("particles[" F_UI "]\&.F[" F_UI "] = " F_LDF,sij\&.neighbor,d,-F_i);
35             }
36         }
37     }
38 }
.fi
.PP
References DEBUG_3, F_LDF, F_UI, pow(), and sqrt()\&.
.SS "template<ui dim> void \fBmd\fP< dim >::thread_cell (\fBui\fP c)"

.PP
Cell indexer for cell c (thread) This function finds the neighbors of all particles in cell \fCc\fP\&. It does this by considering (half of) all neighboring cells, such that no pairs of cells are processed twice\&.
.PP
Definition at line 183 of file index\&.md\&.libmd\&.cc\&.
.PP
.nf
184 {
189     ui nNeighbors; // Number of neighbors of a cell
190     int CellIndices[dim]; // Indices (0 to Q[d]) of cell
191     ldf DissqToEdge[dim][3]; // Distance squared from particle to cell edges
192     ui NeighboringCells[indexdata\&.celldata\&.totNeighbors]; // Cells to check (accounting for boundary conditions)
193     ui NeighborIndex[indexdata\&.celldata\&.totNeighbors]; // Index (0 to totNeighbors) of neighboring cell
194     ui d, i, j, k, p1, cellId;
195     int ci;
196     ldf dissqToCorner, sszsq = std::pow(network\&.ssz,2);
197 
198     // Determine cell indices
199     k = c;
200     for (d = dim-1; d < UI_MAX; d--)
201     {   DEBUG_3("indexdata\&.celldata\&.Q[" F_UI "]= " F_UI "", d, indexdata\&.celldata\&.Q[d]);
202         CellIndices[d] = k % indexdata\&.celldata\&.Q[d];
203         k /= indexdata\&.celldata\&.Q[d];
204     }
205 
206     // Determine all neighbors
207     nNeighbors = 0;
208     for (k = 0; k < indexdata\&.celldata\&.totNeighbors; k++)
209     {   cellId = 0;
210         for (d = 0; d < dim && (((ci = CellIndices[d]+indexdata\&.celldata\&.IndexDelta[k][d]) < (int)indexdata\&.celldata\&.Q[d] && ci >= 0)
211                                 || ((simbox\&.bcond[d] == BCOND::PERIODIC || simbox\&.bcond[d] == BCOND::BOXSHEAR) && indexdata\&.celldata\&.Q[d] != 2)); d++)
212             cellId = indexdata\&.celldata\&.Q[d] * cellId + (indexdata\&.celldata\&.Q[d] + ci) % indexdata\&.celldata\&.Q[d];
213         if (d == dim)
214         {   NeighboringCells[nNeighbors] = cellId;
215             NeighborIndex[nNeighbors] = k;
216             nNeighbors++;
217         }
218     }
219 
220     // Loop over all particles in this cell
221     for (i = indexdata\&.celldata\&.Cells[c]\&.size()-1; i < UI_MAX; i--)
222     {   p1 = indexdata\&.celldata\&.Cells[c][i];
223 
224         // Loop over all remaining particles in the same cell
225         for (j = i-1; j < UI_MAX; j--)
226             skinner(p1, indexdata\&.celldata\&.Cells[c][j], sszsq);
227 
228         if (simbox\&.useLshear || indexdata\&.celldata\&.OutsideBox[i])
229         {   // Loop over neighboring cells
230             for (k = 0; k < nNeighbors; k++)
231             {   // Check all particles in cell
232                 for (ui p2 : indexdata\&.celldata\&.Cells[NeighboringCells[k]])
233                     skinner(p1, p2, sszsq);
234             }
235         }
236         else
237         {   for (d = 0; d < dim; d++)
238             {   DissqToEdge[d][1] = 0;
239                 if (indexdata\&.celldata\&.Q[d] == 2 && (simbox\&.bcond[d] == BCOND::PERIODIC || simbox\&.bcond[d] == BCOND::BOXSHEAR)) // Special case: two cells and pbc
240                     DissqToEdge[d][0] = DissqToEdge[d][2] = std::pow(indexdata\&.celldata\&.CellSize[d]/2 - std::abs((CellIndices[d]+\&.5) * indexdata\&.celldata\&.CellSize[d] - simbox\&.L[d]/2 - particles[p1]\&.x[d]), 2);
241                 else
242                 {   DissqToEdge[d][0] = std::pow(simbox\&.L[d]/2 + particles[p1]\&.x[d] - CellIndices[d] * indexdata\&.celldata\&.CellSize[d], 2);
243                     DissqToEdge[d][2] = std::pow((CellIndices[d]+1) * indexdata\&.celldata\&.CellSize[d] - simbox\&.L[d]/2 - particles[p1]\&.x[d], 2);
244                 }
245             }
246 
247             // Loop over neighboring cells
248             for (k = 0; k < nNeighbors; k++)
249             {
250                 // Calculate distance (squared) to closest corner
251                 dissqToCorner = 0;
252                 for (d = 0; d < dim; d++)
253                     dissqToCorner += DissqToEdge[d][indexdata\&.celldata\&.IndexDelta[NeighborIndex[k]][d]+1];
254                 // Ignore cell if it is more than sszsq away
255                 if (dissqToCorner < sszsq)
256                     // Check all particles in cell
257                     for (ui p2 : indexdata\&.celldata\&.Cells[NeighboringCells[k]])
258                         skinner(p1, p2, sszsq);
259             }
260         }
261     }
262 }
.fi
.PP
References abs(), BCOND::BOXSHEAR, DEBUG_3, F_UI, BCOND::PERIODIC, pow(), and UI_MAX\&.
.SS "template<ui dim> void \fBmd\fP< dim >::thread_clear_forces (\fBui\fP i)"

.PP
Clear forces for particle i\&. Clear the forces variable of particle \fCi\fP
.PP
Definition at line 6 of file forces\&.md\&.libmd\&.cc\&.
.PP
.nf
7 {
11     memset(particles[i]\&.F,0,dim*sizeof(ldf));
12 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::thread_first_order (\fBui\fP i)"

.PP
First order (Euler) integrator (threaded) This function integrates particle position \fCi\fP using Euler first order\&. 
.br
 This is useful for implementing Vicsek type models
.PP
Definition at line 54 of file integrator\&.md\&.libmd\&.cc\&.
.PP
.nf
55 {
60     memcpy(particles[i]\&.xp,particles[i]\&.x,dim*sizeof(ldf));
61     for(ui d=0;d<dim;d++) particles[i]\&.x[d]+=integrator\&.h*particles[i]\&.dx[d];
62 }
.fi
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::thread_H (\fBui\fP i)"

.PP
Measure Hamiltonian for particle i\&. Returns the total energy (kinetic and potential) of particle \fCi\fP\&.
.PP
Definition at line 6 of file energy\&.md\&.libmd\&.cc\&.
.PP
.nf
7 {
11     return T(i)+V(i);
12 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::thread_index_stick (\fBui\fP i)"

.PP
Save the particle position at indexing\&. This function copies the current position \fCx[]\fP of particle \fCi\fP to \fCxsk[]\fP, for use by \fBmd<dim>::test_index()\fP\&.
.PP
Definition at line 6 of file index\&.md\&.libmd\&.cc\&.
.PP
.nf
7 {
11     memcpy(particles[i]\&.xsk,particles[i]\&.x,dim*sizeof(ldf));
12 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::thread_overdamped (\fBui\fP i)"

.PP
First order (Euler) integrator for overdamped dynamics (threaded) This function integrates particle position \fCi\fP using Euler first order\&. 
.br
 This is useful for implementing overdamped systems
.PP
Definition at line 64 of file integrator\&.md\&.libmd\&.cc\&.
.PP
.nf
65 {
70     memcpy(particles[i]\&.xp,particles[i]\&.x,dim*sizeof(ldf));
71     for(ui d=0;d<dim;d++) particles[i]\&.dx[d]=-particles[i]\&.F[d]/avars\&.overdamped_gamma;
72     for(ui d=0;d<dim;d++) particles[i]\&.x[d]+=integrator\&.h*particles[i]\&.dx[d];
73 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::thread_periodicity (\fBldf\fP x[dim])"

.PP
Apply periodicity to one particle only\&. This function loops through the \fCdim\fP dimensions, and updates the position and velocity of particle \fCi\fP to respect the boundary conditions of any boundary it might have passed through in the last time step\&.
.PP
Definition at line 16 of file periodicity\&.md\&.libmd\&.cc\&.
.PP
.nf
17 {
23     for(ui d=0;d<dim;d++) boundary(d,x,this);
24 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::thread_periodicity (\fBui\fP i)"

.PP
Apply periodicity to one particle only\&. This function loops through the \fCdim\fP dimensions, and updates the position and velocity of particle \fCi\fP to respect the boundary conditions of any boundary it might have passed through in the last time step\&.
.PP
Definition at line 6 of file periodicity\&.md\&.libmd\&.cc\&.
.PP
.nf
7 {
13     for(ui d=0;d<dim;d++) boundary(d,i,this);
14 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::thread_seuler (\fBui\fP i)"

.PP
Symplectic euler integrator (threaded) This function integrates particle \fCi\fP using symplectic Euler\&. 
.br
 The symplectic Euler integrator is simpelest (and fastest) symplectic integrator\&. 
.br
 The integrator is a first order integrator\&. 
.br
 Sometimes symplectic Euler is also refered: to as Semi-implicit Euler, Euler--Cromer or Newton-Stoermer-Verlet\&. 
.br
 Symplectic Euler takes the following form: \begin{align} \dot{x}^{\mu}_{t+1}=&\dot{x}^{\mu}_{t}+\tfrac{h}{m} F^{\mu}_{t}\\ x^{\mu}_{t+1}=& x^{\mu}_{t}+h\dot{x}^{\mu}_{t+1}\end{align}
.PP
Definition at line 6 of file integrator\&.md\&.libmd\&.cc\&.
.PP
.nf
7 {
16     ldf o=integrator\&.h/particles[i]\&.m;
17     memcpy(particles[i]\&.xp,particles[i]\&.x,dim*sizeof(ldf));
18     for(ui d=0;d<dim;d++)
19     {
20         particles[i]\&.dx[d]+=o*particles[i]\&.F[d];
21         particles[i]\&.x[d]+=integrator\&.h*particles[i]\&.dx[d];
22     }
23 }
.fi
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::thread_T (\fBui\fP i)\fC [virtual]\fP"

.PP
Measure kinetic energy for particle i\&. Returns the kinetic energy of particle \fCi\fP\&.
.PP
Reimplemented in \fBmpmd< dim >\fP\&.
.PP
Definition at line 14 of file energy\&.md\&.libmd\&.cc\&.
.PP
.nf
15 {
19     ldf retval=0\&.0;
20     for(ui d=0;d<dim;d++) retval+=std::pow(particles[i]\&.dx[d],2);
21     return 0\&.5*particles[i]\&.m*retval;
22 }
.fi
.PP
References pow()\&.
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::thread_V (\fBui\fP i, bool higher_index_only = \fCfalse\fP)\fC [virtual]\fP"

.PP
Measure potential energy for particle i\&. Returns the potential energy of particle \fCi\fP\&. If \fChigher_index_only\fP is \fCtrue\fP, it only incorporates interactions with particles with a higher index\&.
.PP
Reimplemented in \fBmpmd< dim >\fP\&.
.PP
Definition at line 24 of file energy\&.md\&.libmd\&.cc\&.
.PP
.nf
25 {
30     ldf retval=0\&.0;
31     ldf rcosq=std::pow(network\&.rco,2);
32     for(auto sij: network\&.skins[i]) if(!higher_index_only or i<sij\&.neighbor)
33     {
34         const ldf rsq=distsq(i,sij\&.neighbor);
35         if(rsq<rcosq)
36         {
37             const ldf r=std::sqrt(rsq);
38             retval+=v(network\&.library[sij\&.interaction]\&.potential,r,network\&.library[sij\&.interaction]\&.parameters);
39             if(network\&.update) retval-=network\&.library[sij\&.interaction]\&.vco;
40         }
41     }
42     return retval;
43 }
.fi
.PP
References pow(), and sqrt()\&.
.SS "template<ui dim> void \fBmd\fP< dim >::thread_vverlet_dx (\fBui\fP i)"

.PP
Velocity verlet integrator for velocity (threaded) This function integrates particle velocity \fCi\fP using Velocity Verlet\&. 
.br
 See \fBmd<dim>::thread_vverlet_x\fP for the particle position part\&. 
.br
 Velocity Verlet is a second order symplectic integrator\&. 
.br
 It is slower than symplectic Euler (see \fBmd<dim>::thread_seuler\fP), yet more accurate\&. 
.br
 Velocity Verlet takes the following form: \begin{align}x^{\mu}_{t+1}=&x^{\mu}_{t}+h\dot{x}^{\mu}_{t}+\tfrac{h^2}{2}F^{\mu}_{t}\\ \dot{x}^{\mu}_{t+1}=&\dot{x}^{\mu}_{t}+\tfrac{h}{2}(F^{\mu}_{t}+F^{\mu}_{t+1})\end{align} Because of the second force ( $F^{\mu}_{t+1}$) calculation this function is split in two\&. 
.br

.PP
Definition at line 40 of file integrator\&.md\&.libmd\&.cc\&.
.PP
.nf
41 {
51     for(ui d=0;d<dim;d++) particles[i]\&.dx[d]+=0\&.5*integrator\&.h*particles[i]\&.F[d]/particles[i]\&.m;
52 }
.fi
.SS "template<ui dim> void \fBmd\fP< dim >::thread_vverlet_x (\fBui\fP i)"

.PP
Velocity verlet integrator for position (threaded) This function integrates particle position \fCi\fP using Velocity Verlet\&. 
.br
 See \fBmd<dim>::thread_vverlet_dx\fP for the particle velocity part\&. 
.br
 Velocity Verlet is a second order symplectic integrator\&. 
.br
 It is slower than symplectic Euler (see \fBmd<dim>::thread_seuler\fP), yet more accurate\&. 
.br
 Velocity Verlet takes the following form: \begin{align}x^{\mu}_{t+1}=&x^{\mu}_{t}+h\dot{x}^{\mu}_{t}+\tfrac{h^2}{2}F^{\mu}_{t}\\ \dot{x}^{\mu}_{t+1}=&\dot{x}^{\mu}_{t}+\tfrac{h}{2}(F^{\mu}_{t}+F^{\mu}_{t+1})\end{align} Because of the second force ( $F^{\mu}_{t+1}$) calculation this function is split in two\&. 
.br

.PP
Definition at line 25 of file integrator\&.md\&.libmd\&.cc\&.
.PP
.nf
26 {
36     memcpy(particles[i]\&.xp,particles[i]\&.x,dim*sizeof(ldf));
37     for(ui d=0;d<dim;d++) particles[i]\&.x[d]+=integrator\&.h*particles[i]\&.dx[d]+0\&.5*std::pow(integrator\&.h,2)*particles[i]\&.F[d]/particles[i]\&.m;
38 }
.fi
.PP
References pow()\&.
.SS "template<ui dim> void \fBmd\fP< dim >::timestep"

.PP
Do one timestep\&. This function defines a timestep by combining the \fBmd<dim>::calc_forces\fP and \fBmd<dim>::integrate\fP functions\&. 
.br
 If there is a boxshear present it updates the boundaries\&.
.PP
Definition at line 106 of file integrator\&.md\&.libmd\&.cc\&.
.PP
.nf
107 {
112     if(simbox\&.useLshear)
113     {
114         DEBUG_2("updating boxshear boundaries");
115         update_boundaries();
116     }
117     calc_forces();
118     integrate();
119     run_hooks();
120 }
.fi
.PP
References DEBUG_2\&.
.SS "template<ui dim> void \fBmd\fP< dim >::timesteps (\fBui\fP k)"

.PP
Do multiple timesteps\&. This function calls \fBmd<dim>::timestep\fP \fCk\fP times\&.
.br
 (The looped is sandwiched between DEBUG_TIMER statements\&.)
.PP
Definition at line 122 of file integrator\&.md\&.libmd\&.cc\&.
.PP
.nf
123 {
128     DEBUG_TIMER("start timesteps");
129     for(ui i=0;i<k;i++) timestep();
130     DEBUG_TIMER("stop timesteps");
131 }
.fi
.PP
References DEBUG_TIMER\&.
.SS "template<ui dim> void \fBmd\fP< dim >::translate_particle (\fBui\fP i, \fBldf\fP x[dim])"

.PP
Translate (or move) a particle\&. This function translates particle \fCi\fP by the vector \fCx[]\fP\&.
.PP
Definition at line 173 of file particles\&.md\&.libmd\&.cc\&.
.PP
.nf
174 {
178     DEBUG_2("translating particle #" F_UI "",i);
179     avars\&.export_force_calc=true;
180     for(ui d=0;d<dim;d++)
181     {
182         particles[i]\&.x[d]+=x[d];
183         particles[i]\&.xp[d]+=x[d];
184     }
185     thread_periodicity(i);
186     avars\&.reindex=true;
187 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> void \fBmd\fP< dim >::translate_sp (\fBui\fP spi, \fBldf\fP x[dim])"

.PP
Translate (or move) a super particle\&. This function translates all particles belonging to the superparticle with index \fCspi\fP by the vector \fCx[]\fP\&.
.PP
Definition at line 223 of file sp\&.md\&.libmd\&.cc\&.
.PP
.nf
224 {
228     DEBUG_2("translating superparticle #" F_UI "",spi);
229     for(auto it=network\&.superparticles[spi]\&.particles\&.begin();it!=network\&.superparticles[spi]\&.particles\&.end();it++) translate_particle(it->first,x);
230 }
.fi
.PP
References DEBUG_2, and F_UI\&.
.SS "template<ui dim> void \fBmd\fP< dim >::unassign_all_forcetype (\fBui\fP ftype)"

.PP
Unassign force type to all particles\&. This function removes the forcetype \fCnetwork\&.forcelibrary[ftype]\fP from all particles\&.
.PP
Definition at line 625 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
626 {
630     for(ui i=0;i<N;i++) unassign_forcetype(i,ftype);
631 }
.fi
.SS "template<ui dim> bool \fBmd\fP< dim >::unassign_forcetype (\fBui\fP i, \fBui\fP ftype)"

.PP
Unassign force type to particle\&. This function removes the forcetype \fCnetwork\&.forcelibrary[ftype]\fP from particle \fCi\fP\&. It returns whether the given forcetype was assigned to the given particle\&.
.PP
Definition at line 610 of file interaction\&.md\&.libmd\&.cc\&.
.PP
.nf
611 {
616     for(ui j=network\&.forces[i]\&.size()-1;j<UI_MAX;j--) if(network\&.forces[i][j]==ftype)
617     {
618         network\&.forces[i][j]=network\&.forces[i]\&.back();
619         network\&.forces[i]\&.pop_back();
620         return true;
621     }
622     return false;
623 }
.fi
.PP
References UI_MAX\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::unset_damping"

.PP
Disables damping\&. This function disables damping and returns whether it was set\&.
.PP
Definition at line 25 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
26 {
30     if(avars\&.noftypedamping<UI_MAX)
31     {
32         DEBUG_2("disabling damping");
33         rem_forcetype(avars\&.noftypedamping);
34         avars\&.noftypedamping=UI_MAX;
35         return true;
36     }
37     else
38     {
39         WARNING("no damping set");
40         return false;
41     }
42 }
.fi
.PP
References DEBUG_2, UI_MAX, and WARNING\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::unset_langevin"

.PP
Disable Langevin thermostat\&. This function disables Langevin thermostat and returns whether it was set\&.
.PP
Definition at line 66 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
67 {
71     if(avars\&.noftypelangevin<UI_MAX)
72     {
73         DEBUG_2("disabling Langevin thermostat");
74         rem_forcetype(avars\&.noftypelangevin);
75         rem_forcetype(avars\&.noftypedamping);
76         avars\&.noftypelangevin=UI_MAX;
77         avars\&.noftypedamping=UI_MAX;
78         return true;
79     }
80     else
81     {
82         WARNING("no Langevin thermostat set");
83         return false;
84     }
85 }
.fi
.PP
References DEBUG_2, UI_MAX, and WARNING\&.
.SS "template<ui dim> bool \fBmd\fP< dim >::unset_overdamped"

.PP
Disable overdamped dynamics\&. This function restors the old integrator iff set_overdamped is used
.PP
Definition at line 103 of file setget\&.md\&.libmd\&.cc\&.
.PP
.nf
104 {
108     if(avars\&.overdamped_pre_integrator!=INTEGRATOR::FO_OVERDAMPED)
109     {
110         integrator\&.method=avars\&.overdamped_pre_integrator;
111         return true;
112     }
113     else
114     {
115         WARNING("unset_overdamped cannot unset overdamped dynamics as no other dynamics was previously defined");
116         return false;
117     }
118 }
.fi
.PP
References INTEGRATOR::FO_OVERDAMPED, and WARNING\&.
.SS "template<ui dim> void \fBmd\fP< dim >::update_boundaries"

.PP
Shifts the periodic boxes appropriately for sheared BC\&. Update the box matrix using the shear velocities\&. Increments the box matrix $L_{ij}$ (stored in \fCsimbox\&.Lshear\fP) by $h\times v_{ij}$ where $v_{ij}$ is the shear velocity matrix (stored in \fCsimbox\&.vshear\fP) and $h$ is the integration timestep (stored in \fCintegrator\&.h\fP)\&. 
.br
 Also shifts $L_{ij}$ to ensure that it remains within the bounds $-L_{ii}/2 \leq L_{ij} \leq L_{ii}/2$\&.
.PP
Definition at line 43 of file periodicity\&.md\&.libmd\&.cc\&.
.PP
.nf
44 {
54     // update box matrix for shear
55     for(ui j=0;j<dim;j++) for (ui k=0; k<dim; k++)
56     {
57         simbox\&.Lshear[j][k] += simbox\&.vshear[j][k]*integrator\&.h;
58         // shift by appropriate box lengths so that the off-diagonal entries are in the range -L[j][j]/2 to L[j][j]/2 consistent with the positions
59         if (j != k && (simbox\&.bcond[j]==BCOND::PERIODIC || simbox\&.bcond[j]==BCOND::BOXSHEAR))
60         {
61             while(simbox\&.Lshear[j][k]>simbox\&.Lshear[j][j]/2\&.) simbox\&.Lshear[j][k]-=simbox\&.Lshear[j][j];
62             while(simbox\&.Lshear[j][k]<-simbox\&.Lshear[j][j]/2\&.) simbox\&.Lshear[j][k]+=simbox\&.Lshear[j][j];
63         }
64     }
65     simbox\&.invert_box();
66 }
.fi
.PP
References BCOND::BOXSHEAR, and BCOND::PERIODIC\&.
.SS "template<ui dim> void \fBmd\fP< dim >::update_skins (\fBui\fP p1, \fBui\fP p2)"

.PP
Modify skins after adding/modifying/removing bond\&. Updates the skin lists of \fCp1\fP and \fCp2\fP\&. This function is called by functions that modify pairwise interactions between specific particle pairs, to rebuild the skins taking into account new particle ID assignments and interaction definitions\&.
.PP
Definition at line 6 of file bonds\&.md\&.libmd\&.cc\&.
.PP
.nf
7 {
14     ui interaction, s, t, j, k;
15     std::pair<ui,ui> id;
16     if ((s = network\&.spid[p1]) < UI_MAX && s == network\&.spid[p2]
17         && network\&.sptypes[t = network\&.superparticles[s]\&.sptype]\&.splookup\&.count(id = network\&.hash(network\&.superparticles[s]\&.particles[p1], network\&.superparticles[s]\&.particles[p2])))
18         interaction = network\&.sptypes[t]\&.splookup[id];
19     else if (network\&.lookup\&.count(id = network\&.hash(particles[p1]\&.type, particles[p2]\&.type)))
20         interaction = network\&.lookup[id];
21     else
22         interaction = UI_MAX;
23     for (j = network\&.skins[p1]\&.size()-1; j < UI_MAX && network\&.skins[p1][j]\&.neighbor != p2; j--);
24     if (j < UI_MAX)
25     {
26         for (k = network\&.skins[p2]\&.size()-1; network\&.skins[p2][k]\&.neighbor != p1; k--);
27         if (interaction < UI_MAX)
28             network\&.skins[p1][j]\&.interaction = network\&.skins[p2][k]\&.interaction = interaction;
29         else
30         {   std::iter_swap(network\&.skins[p1]\&.begin()+j, network\&.skins[p1]\&.rbegin());
31             network\&.skins[p1]\&.pop_back();
32             std::iter_swap(network\&.skins[p2]\&.begin()+k, network\&.skins[p2]\&.rbegin());
33             network\&.skins[p2]\&.pop_back();
34         }
35     }
36     else if (interaction < UI_MAX)
37     {   network\&.skins[p1]\&.push_back(interactionneighbor(p2,interaction));
38         network\&.skins[p2]\&.push_back(interactionneighbor(p1,interaction));
39     }
40 }
.fi
.PP
References UI_MAX\&.
.SS "template<ui dim> \fBldf\fP \fBmd\fP< dim >::V"

.PP
Measure potential energy\&. Returns the total potential energy of the system
.PP
Definition at line 63 of file energy\&.md\&.libmd\&.cc\&.
.PP
.nf
64 {
68     ldf retval=0\&.0;
69     for(ui i=0;i<N;i++) retval+=thread_V(i,true);
70     return retval;
71 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "template<ui dim> \fBadditional_vars\fP<dim> \fBmd\fP< dim >::avars"

.PP
Bunch of additonal variables\&. 
.PP
Definition at line 388 of file libmd\&.h\&.
.SS "template<ui dim> \fBbcond\fP<dim> \fBmd\fP< dim >::boundary"

.PP
Boundary conditions functor\&. 
.PP
Definition at line 379 of file libmd\&.h\&.
.SS "template<ui dim> \fBexternalforces\fP<dim> \fBmd\fP< dim >::f"

.PP
External forces functor\&. 
.PP
Definition at line 384 of file libmd\&.h\&.
.SS "template<ui dim> \fBhooker\fP<dim> \fBmd\fP< dim >::hooks"

.PP
Hook functor\&. 
.PP
Definition at line 385 of file libmd\&.h\&.
.SS "template<ui dim> \fBindexer\fP<dim> \fBmd\fP< dim >::indexdata"

.PP
Data structure for indexing\&. 
.PP
Definition at line 382 of file libmd\&.h\&.
.SS "template<ui dim> \fBintegrators\fP \fBmd\fP< dim >::integrator"

.PP
Integration method\&. 
.PP
Definition at line 386 of file libmd\&.h\&.
.SS "template<ui dim> \fBui\fP \fBmd\fP< dim >::N"

.PP
Number of particles\&. 
.PP
Definition at line 377 of file libmd\&.h\&.
.SS "template<ui dim> \fBinteract\fP \fBmd\fP< dim >::network"

.PP
Interaction network\&. 
.PP
Definition at line 381 of file libmd\&.h\&.
.SS "template<ui dim> std::vector<\fBparticle\fP<dim> > \fBmd\fP< dim >::particles"

.PP
Particle array\&. 
.PP
Definition at line 380 of file libmd\&.h\&.
.SS "template<ui dim> \fBbox\fP<dim> \fBmd\fP< dim >::simbox"

.PP
Simulation box\&. 
.PP
Definition at line 378 of file libmd\&.h\&.
.SS "template<ui dim> \fBpairpotentials\fP \fBmd\fP< dim >::v"

.PP
Pair potential functor\&. 
.PP
Definition at line 383 of file libmd\&.h\&.
.SS "template<ui dim> \fBvariadic_vars\fP<dim> \fBmd\fP< dim >::vvars"

.PP
Bunch of variables for variadic functions\&. 
.PP
Definition at line 387 of file libmd\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libmd from the source code\&.
