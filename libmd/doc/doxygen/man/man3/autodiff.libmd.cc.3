.TH "libmd-src/autodiff.libmd.cc" 3 "Thu Sep 3 2020" "Version -0." "libmd" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libmd-src/autodiff.libmd.cc
.SH SYNOPSIS
.br
.PP
\fC#include '\&.\&./libmd\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB__libmd_src_file__\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBoperator==\fP (\fBdual\fP F, \fBdual\fP G)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (\fBdual\fP F, \fBdual\fP G)"
.br
.ti -1c
.RI "bool \fBoperator<=\fP (\fBdual\fP F, \fBdual\fP G)"
.br
.ti -1c
.RI "bool \fBoperator>=\fP (\fBdual\fP F, \fBdual\fP G)"
.br
.ti -1c
.RI "bool \fBoperator<\fP (\fBdual\fP F, \fBdual\fP G)"
.br
.ti -1c
.RI "bool \fBoperator>\fP (\fBdual\fP F, \fBdual\fP G)"
.br
.ti -1c
.RI "template<class X > bool \fBoperator==\fP (\fBdual\fP &F, X a)"
.br
.ti -1c
.RI "template<class X > bool \fBoperator!=\fP (\fBdual\fP &F, X a)"
.br
.ti -1c
.RI "template<class X > bool \fBoperator<=\fP (\fBdual\fP &F, X a)"
.br
.ti -1c
.RI "template<class X > bool \fBoperator>=\fP (\fBdual\fP &F, X a)"
.br
.ti -1c
.RI "template<class X > bool \fBoperator<\fP (\fBdual\fP F, X a)"
.br
.ti -1c
.RI "template<class X > bool \fBoperator>\fP (\fBdual\fP F, X a)"
.br
.ti -1c
.RI "template<class X > bool \fBoperator==\fP (X a, \fBdual\fP &F)"
.br
.ti -1c
.RI "template<class X > bool \fBoperator!=\fP (X a, \fBdual\fP &F)"
.br
.ti -1c
.RI "template<class X > bool \fBoperator<=\fP (X a, \fBdual\fP &F)"
.br
.ti -1c
.RI "template<class X > bool \fBoperator>=\fP (X a, \fBdual\fP &F)"
.br
.ti -1c
.RI "template<class X > bool \fBoperator<\fP (X a, \fBdual\fP F)"
.br
.ti -1c
.RI "template<class X > bool \fBoperator>\fP (X a, \fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBoperator\-\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBoperator+\fP (\fBdual\fP F, \fBdual\fP G)"
.br
.ti -1c
.RI "\fBdual\fP \fBoperator\-\fP (\fBdual\fP F, \fBdual\fP G)"
.br
.ti -1c
.RI "\fBdual\fP \fBoperator*\fP (\fBdual\fP F, \fBdual\fP G)"
.br
.ti -1c
.RI "\fBdual\fP \fBoperator/\fP (\fBdual\fP F, \fBdual\fP G)"
.br
.ti -1c
.RI "\fBdual\fP \fBoperator+=\fP (\fBdual\fP &F, \fBdual\fP G)"
.br
.ti -1c
.RI "\fBdual\fP \fBoperator\-=\fP (\fBdual\fP &F, \fBdual\fP G)"
.br
.ti -1c
.RI "\fBdual\fP \fBoperator*=\fP (\fBdual\fP &F, \fBdual\fP G)"
.br
.ti -1c
.RI "\fBdual\fP \fBoperator/=\fP (\fBdual\fP &F, \fBdual\fP G)"
.br
.ti -1c
.RI "template<class X > \fBdual\fP \fBoperator+\fP (\fBdual\fP F, X a)"
.br
.ti -1c
.RI "template<class X > \fBdual\fP \fBoperator\-\fP (\fBdual\fP F, X a)"
.br
.ti -1c
.RI "template<class X > \fBdual\fP \fBoperator*\fP (\fBdual\fP F, X a)"
.br
.ti -1c
.RI "template<class X > \fBdual\fP \fBoperator/\fP (\fBdual\fP F, X a)"
.br
.ti -1c
.RI "template<class X > \fBdual\fP \fBoperator+\fP (X a, \fBdual\fP F)"
.br
.ti -1c
.RI "template<class X > \fBdual\fP \fBoperator\-\fP (X a, \fBdual\fP F)"
.br
.ti -1c
.RI "template<class X > \fBdual\fP \fBoperator*\fP (X a, \fBdual\fP F)"
.br
.ti -1c
.RI "template<class X > \fBdual\fP \fBoperator/\fP (X a, \fBdual\fP F)"
.br
.ti -1c
.RI "template<class X > \fBdual\fP \fBoperator+=\fP (\fBdual\fP &F, X a)"
.br
.ti -1c
.RI "template<class X > \fBdual\fP \fBoperator\-=\fP (\fBdual\fP &F, X a)"
.br
.ti -1c
.RI "template<class X > \fBdual\fP \fBoperator*=\fP (\fBdual\fP &F, X a)"
.br
.ti -1c
.RI "template<class X > \fBdual\fP \fBoperator/=\fP (\fBdual\fP &F, X a)"
.br
.ti -1c
.RI "\fBdual\fP \fBsqrt\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "template<class X > \fBdual\fP \fBpow\fP (\fBdual\fP F, X n)"
.br
.ti -1c
.RI "\fBdual\fP \fBexp\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "template<class X > \fBdual\fP \fBpow\fP (X a, \fBdual\fP G)"
.br
.ti -1c
.RI "\fBdual\fP \fBpow\fP (\fBdual\fP F, \fBdual\fP G)"
.br
.ti -1c
.RI "\fBdual\fP \fBlog\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBsin\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBcos\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBtan\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBsinh\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBcosh\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBtanh\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBasin\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBacos\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBatan\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBasinh\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBacosh\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBatanh\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBabs\fP (\fBdual\fP F)"
.br
.ti -1c
.RI "\fBdual\fP \fBheaviside\fP (\fBdual\fP F)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define __libmd_src_file__"

.PP
Definition at line 1 of file autodiff\&.libmd\&.cc\&.
.SH "Function Documentation"
.PP 
.SS "\fBdual\fP abs (\fBdual\fP F)"

.PP
Definition at line 364 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
365 {
366     return F\&.x<0\&.0?-F:F;
367 }
.fi
.PP
References dual::x\&.
.SS "\fBdual\fP acos (\fBdual\fP F)"

.PP
Definition at line 339 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
340 {
341     return dual(std::acos(F\&.x),-F\&.dx/std::sqrt(1\&.0-std::pow(F\&.x,2)));
342 }
.fi
.PP
References dual::dx, pow(), sqrt(), and dual::x\&.
.SS "\fBdual\fP acosh (\fBdual\fP F)"

.PP
Definition at line 354 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
355 {
356     return dual(std::acosh(F\&.x),-F\&.dx/std::sqrt(std::pow(F\&.x,2)-1\&.0));
357 }
.fi
.PP
References dual::dx, pow(), sqrt(), and dual::x\&.
.SS "\fBdual\fP asin (\fBdual\fP F)"

.PP
Definition at line 334 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
335 {
336     return dual(std::asin(F\&.x),F\&.dx/std::sqrt(1\&.0-std::pow(F\&.x,2)));
337 }
.fi
.PP
References dual::dx, pow(), sqrt(), and dual::x\&.
.SS "\fBdual\fP asinh (\fBdual\fP F)"

.PP
Definition at line 349 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
350 {
351     return dual(std::asinh(F\&.x),F\&.dx/std::sqrt(1\&.0+std::pow(F\&.x,2)));
352 }
.fi
.PP
References dual::dx, pow(), sqrt(), and dual::x\&.
.SS "\fBdual\fP atan (\fBdual\fP F)"

.PP
Definition at line 344 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
345 {
346     return dual(std::atan(F\&.x),F\&.dx/(std::pow(F\&.x,2)+1\&.0));
347 }
.fi
.PP
References dual::dx, pow(), and dual::x\&.
.SS "\fBdual\fP atanh (\fBdual\fP F)"

.PP
Definition at line 359 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
360 {
361     return dual(std::atanh(F\&.x),F\&.dx/(1\&.0-std::pow(F\&.x,2)));
362 }
.fi
.PP
References dual::dx, pow(), and dual::x\&.
.SS "\fBdual\fP cos (\fBdual\fP F)"

.PP
Definition at line 307 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
308 {
309     return dual(std::cos(F\&.x),-F\&.dx*std::sin(F\&.x));
310 }
.fi
.PP
References dual::dx, sin(), and dual::x\&.
.SS "\fBdual\fP cosh (\fBdual\fP F)"

.PP
Definition at line 323 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
324 {
325     return dual(std::cosh(F\&.x),F\&.dx*std::sinh(F\&.x));
326 }
.fi
.PP
References dual::dx, sinh(), and dual::x\&.
.SS "\fBdual\fP exp (\fBdual\fP F)"

.PP
Definition at line 279 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
280 {
281     const ldf ex=std::exp(F\&.x);
282     return dual(ex,F\&.dx*ex);
283 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "\fBdual\fP heaviside (\fBdual\fP F)"

.PP
Definition at line 369 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
370 {
371     return dual(F\&.x<0\&.0?0\&.0:1\&.0, F\&.x==0\&.0?std::numeric_limits<ldf>::infinity():0\&.0);
372 }
.fi
.SS "\fBdual\fP log (\fBdual\fP F)"

.PP
Definition at line 297 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
298 {
299     return dual(std::log(F\&.x),F\&.dx/F\&.x);
300 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "template<class X > bool operator!= (\fBdual\fP & F, X a)"

.PP
Definition at line 89 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
90 {
91     return F\&.x!=a;
92 }
.fi
.PP
References dual::x\&.
.SS "bool operator!= (\fBdual\fP F, \fBdual\fP G)"

.PP
Definition at line 59 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
60 {
61     return F\&.x!=G\&.x;
62 }
.fi
.PP
References dual::x\&.
.SS "template<class X > bool operator!= (X a, \fBdual\fP & F)"

.PP
Definition at line 119 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
120 {
121     return a!=F\&.x;
122 }
.fi
.PP
References dual::x\&.
.SS "\fBdual\fP operator* (\fBdual\fP F, \fBdual\fP G)"

.PP
Definition at line 162 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
163 {
164     return dual(F\&.x*G\&.x,F\&.dx*G\&.x+F\&.x*G\&.dx);
165 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "template<class X > \fBdual\fP operator* (\fBdual\fP F, X a)"

.PP
Definition at line 209 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
210 {
211     return dual(F\&.x*a,F\&.dx*a);
212 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "template<class X > \fBdual\fP operator* (X a, \fBdual\fP F)"

.PP
Definition at line 229 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
230 {
231     return F*a;
232 }
.fi
.SS "\fBdual\fP operator*= (\fBdual\fP & F, \fBdual\fP G)"

.PP
Definition at line 186 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
187 {
188     return F=F*G;
189 }
.fi
.SS "template<class X > \fBdual\fP operator*= (\fBdual\fP & F, X a)"

.PP
Definition at line 251 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
252 {
253     F\&.x*=a;
254     F\&.dx*=a;
255     return F;
256 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "\fBdual\fP operator+ (\fBdual\fP F, \fBdual\fP G)"

.PP
Definition at line 152 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
153 {
154     return dual(F\&.x+G\&.x, F\&.dx+G\&.dx);
155 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "template<class X > \fBdual\fP operator+ (\fBdual\fP F, X a)"

.PP
Definition at line 199 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
200 {
201     return dual(F\&.x+a,F\&.dx);
202 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "template<class X > \fBdual\fP operator+ (X a, \fBdual\fP F)"

.PP
Definition at line 219 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
220 {
221     return F+a;
222 }
.fi
.SS "\fBdual\fP operator+= (\fBdual\fP & F, \fBdual\fP G)"

.PP
Definition at line 172 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
173 {
174     F\&.x+=G\&.x;
175     F\&.dx+=G\&.dx;
176     return F;
177 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "template<class X > \fBdual\fP operator+= (\fBdual\fP & F, X a)"

.PP
Definition at line 239 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
240 {
241     F\&.x+=a;
242     return F;
243 }
.fi
.PP
References dual::x\&.
.SS "\fBdual\fP operator\- (\fBdual\fP F)"

.PP
Definition at line 147 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
148 {
149     return dual(-F\&.x,-F\&.dx);
150 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "\fBdual\fP operator\- (\fBdual\fP F, \fBdual\fP G)"

.PP
Definition at line 157 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
158 {
159     return dual(F\&.x-G\&.x, F\&.dx-G\&.dx);
160 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "template<class X > \fBdual\fP operator\- (\fBdual\fP F, X a)"

.PP
Definition at line 204 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
205 {
206     return dual(F\&.x-a,F\&.dx);
207 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "template<class X > \fBdual\fP operator\- (X a, \fBdual\fP F)"

.PP
Definition at line 224 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
225 {
226     return (-F)+a;
227 }
.fi
.SS "\fBdual\fP operator\-= (\fBdual\fP & F, \fBdual\fP G)"

.PP
Definition at line 179 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
180 {
181     F\&.x-=G\&.x;
182     F\&.dx-=G\&.dx;
183     return F;
184 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "template<class X > \fBdual\fP operator\-= (\fBdual\fP & F, X a)"

.PP
Definition at line 245 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
246 {
247     F\&.x-=a;
248     return F;
249 }
.fi
.PP
References dual::x\&.
.SS "\fBdual\fP operator/ (\fBdual\fP F, \fBdual\fP G)"

.PP
Definition at line 167 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
168 {
169     return dual(F\&.x/G\&.x,(F\&.dx*G\&.x-F\&.x*G\&.dx)/std::pow(G\&.x,2));
170 }
.fi
.PP
References dual::dx, pow(), and dual::x\&.
.SS "template<class X > \fBdual\fP operator/ (\fBdual\fP F, X a)"

.PP
Definition at line 214 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
215 {
216     return dual(F\&.x/a,F\&.dx/a);
217 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "template<class X > \fBdual\fP operator/ (X a, \fBdual\fP F)"

.PP
Definition at line 234 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
235 {
236     return dual(a/F\&.x,-a*F\&.dx/std::pow(F\&.x,2));
237 }
.fi
.PP
References dual::dx, pow(), and dual::x\&.
.SS "\fBdual\fP operator/= (\fBdual\fP & F, \fBdual\fP G)"

.PP
Definition at line 191 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
192 {
193     return F=F/G;
194 }
.fi
.SS "template<class X > \fBdual\fP operator/= (\fBdual\fP & F, X a)"

.PP
Definition at line 258 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
259 {
260     F\&.x/=a;
261     F\&.dx/=a;
262     return F;
263 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "bool operator< (\fBdual\fP F, \fBdual\fP G)"

.PP
Definition at line 74 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
75 {
76     return F\&.x<G\&.x;
77 }
.fi
.PP
References dual::x\&.
.SS "template<class X > bool operator< (\fBdual\fP F, X a)"

.PP
Definition at line 104 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
105 {
106     return F\&.x<a;
107 }
.fi
.PP
References dual::x\&.
.SS "template<class X > bool operator< (X a, \fBdual\fP F)"

.PP
Definition at line 134 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
135 {
136     return a<F\&.x;
137 }
.fi
.PP
References dual::x\&.
.SS "template<class X > bool operator<= (\fBdual\fP & F, X a)"

.PP
Definition at line 94 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
95 {
96     return F\&.x<=a;
97 }
.fi
.PP
References dual::x\&.
.SS "bool operator<= (\fBdual\fP F, \fBdual\fP G)"

.PP
Definition at line 64 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
65 {
66     return F\&.x<=G\&.x;
67 }
.fi
.PP
References dual::x\&.
.SS "template<class X > bool operator<= (X a, \fBdual\fP & F)"

.PP
Definition at line 124 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
125 {
126     return a<=F\&.x;
127 }
.fi
.PP
References dual::x\&.
.SS "template<class X > bool operator== (\fBdual\fP & F, X a)"

.PP
Definition at line 84 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
85 {
86     return F\&.x==a;
87 }
.fi
.PP
References dual::x\&.
.SS "bool operator== (\fBdual\fP F, \fBdual\fP G)"

.PP
Definition at line 54 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
55 {
56     return F\&.x==G\&.x;
57 }
.fi
.PP
References dual::x\&.
.SS "template<class X > bool operator== (X a, \fBdual\fP & F)"

.PP
Definition at line 114 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
115 {
116     return a==F\&.x;
117 }
.fi
.PP
References dual::x\&.
.SS "bool operator> (\fBdual\fP F, \fBdual\fP G)"

.PP
Definition at line 79 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
80 {
81     return F\&.x>G\&.x;
82 }
.fi
.PP
References dual::x\&.
.SS "template<class X > bool operator> (\fBdual\fP F, X a)"

.PP
Definition at line 109 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
110 {
111     return F\&.x>a;
112 }
.fi
.PP
References dual::x\&.
.SS "template<class X > bool operator> (X a, \fBdual\fP F)"

.PP
Definition at line 139 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
140 {
141     return a>F\&.x;
142 }
.fi
.PP
References dual::x\&.
.SS "template<class X > bool operator>= (\fBdual\fP & F, X a)"

.PP
Definition at line 99 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
100 {
101     return F\&.x>=a;
102 }
.fi
.PP
References dual::x\&.
.SS "bool operator>= (\fBdual\fP F, \fBdual\fP G)"

.PP
Definition at line 69 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
70 {
71     return F\&.x>=G\&.x;
72 }
.fi
.PP
References dual::x\&.
.SS "template<class X > bool operator>= (X a, \fBdual\fP & F)"

.PP
Definition at line 129 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
130 {
131     return a>=F\&.x;
132 }
.fi
.PP
References dual::x\&.
.SS "\fBdual\fP pow (\fBdual\fP F, \fBdual\fP G)"

.PP
Definition at line 291 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
292 {
293     const ldf po=std::pow(F\&.x,G\&.x);
294     return dual(po,(G\&.dx*log(F\&.x)+F\&.dx*G\&.x/F\&.x)*po);
295 }
.fi
.PP
References dual::dx, log(), pow(), and dual::x\&.
.SS "template<class X > \fBdual\fP pow (\fBdual\fP F, X n)"

.PP
Definition at line 274 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
275 {
276     return dual(std::pow(F\&.x,n),F\&.dx*n*std::pow(F\&.x,n-1));
277 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "template<class X > \fBdual\fP pow (X a, \fBdual\fP G)"

.PP
Definition at line 285 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
286 {
287     const ldf po=std::pow(a,G\&.x);
288     return dual(po,G\&.dx*log(a)*po);
289 }
.fi
.PP
References dual::dx, log(), pow(), and dual::x\&.
.SS "\fBdual\fP sin (\fBdual\fP F)"

.PP
Definition at line 302 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
303 {
304     return dual(std::sin(F\&.x),F\&.dx*std::cos(F\&.x));
305 }
.fi
.PP
References cos(), dual::dx, and dual::x\&.
.SS "\fBdual\fP sinh (\fBdual\fP F)"

.PP
Definition at line 318 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
319 {
320     return dual(std::sinh(F\&.x),F\&.dx*std::cosh(F\&.x));
321 }
.fi
.PP
References cosh(), dual::dx, and dual::x\&.
.SS "\fBdual\fP sqrt (\fBdual\fP F)"

.PP
Definition at line 268 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
269 {
270     const ldf sqr=std::sqrt(F\&.x);
271     return dual(sqr,F\&.dx/2\&.0/sqr);
272 }
.fi
.PP
References dual::dx, and dual::x\&.
.SS "\fBdual\fP tan (\fBdual\fP F)"

.PP
Definition at line 312 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
313 {
314     const ldf ta=std::tan(F\&.x);
315     return dual(ta,F\&.dx*(1\&.0+std::pow(ta,2)));
316 }
.fi
.PP
References dual::dx, pow(), and dual::x\&.
.SS "\fBdual\fP tanh (\fBdual\fP F)"

.PP
Definition at line 328 of file autodiff\&.libmd\&.cc\&.
.PP
.nf
329 {
330     const ldf ta=std::tanh(F\&.x);
331     return dual(ta,F\&.dx*(1\&.0-std::pow(ta,2)));
332 }
.fi
.PP
References dual::dx, pow(), and dual::x\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for libmd from the source code\&.
